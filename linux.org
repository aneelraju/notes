* linux
** udemy - fundamentals of unix and linux system administration - eduonix
*** where to start
**** linux unix administration
     + an administrator is not expected to be a "walking book". linux has a huge number of commands, with a lot of different options and arguments. effectively using the man pages, and figuring out how a specific command works is an indispensable skill
     + https://en.wikipedia.org/wiki/List_of_Linux_distributions - Linux Distributions
     + most common linux - redhat (centos, oracle linux, fedora), debian (ubuntu), suse
**** getting help on linux
     + MAN pages - manual pages
       + 'man command' - e.g.
       + several sections 
         + commands and applications (man 1)
           + 'man passwd' - modify a user's password - PASSWD(1)
           + 'man 5 smb.conf' - samba configuration file
           + 'man 1 smblclient' - various options of smbclient command 
         + system calls (man 2)
         + library calls (man 3)
         + drivers (man 4)
         + files (man 5)
           + 'ls -l /etc/passwd' - passwd of users and other info
             + 'man 5 passwd' - this give section 5 passwd man page
         + and more
       + you can use (similar to) 'more' or 'less' command shortcuts for navigation
         + '<space>' - moving forward
         + 'ctrl+b' - moving backword
         + 'ctrl+f' - moving forward
         + ':q' - quit
         + '/<keyword>' - search keyword
       + 'man -k keyword' - search for (inside description or title) a specific man page 
         + 'man -k update' 
         + 'man -k printf'
       + 'man -a keyword' - search in the title only and display multiple man pages
         + 'man -a printf' - gives first man page occurance then next and next
**** advance man command
     + 'man -af keyword' - to search only in the title
       + 'man -af passwd'
     + '<command> -h' or '<command>' or '<command> --help' - provide help, sometimes useful as man's are lenghty
       + 'find' - gives option, check 'man find'
     + 'whatis <command>' - to know whether a command is installed on not or want to know it's path
     + to update man page
       + redhat: 'makewhatis'
       + ubuntu, suse: 'mandb'
     + 'which <command>'  - find the path of a command
       + 'java' - gives java command options
       + 'which java' - java path
     + 'history' - list the commands that you have issued
       + 'export HISTTIMEFORAMT="%d/%m/%y %T "' - set env variable to show time stamp
     + 'du:' - find amount of space taken by a file or directory
       + 'du -h -max-depth=1 *' - find the file and directory sizes in the current location in a human readable format
         + 'du -h -d=1 *' - in mac
     + 'echo > file' - empty a file without deleting it
     + other online documentation
       + linux.com
       + kernel.org - related to kernel, sourcecode is available
       + serverfault.com - important one, q&a site
*** package management
**** introduction to package management
     + traditional way
       + download .tar.gz files
       + './configure' and 'make install'
       + doesn't handle dependencies, may overwrite customized configuration files, hard to uninstall
       + centos:
         + % ls -ltr; # download htop-1.0.3.tar.gz
         + % tar -xvf htop-1.0.3.tar.gz; # famous package to monitor cpu and memory performance
         + % ./configure; # check for the system, we don't have gcc compiler
         + % ls -l /etc/ntp.conf; # network time server to sync with your own time; this file can get overwritten during installation and older config can be deleted
     + packages
       + preserves configuration files
         + e.g. if new version of httpd is installed, the httpd.conf is created as httpd.conf.rpmnew
       + dependencies are considered
       + pre and post install scripts can be deployed with the application
       + multiple packages can be wrapped in same package
         + https://www.libreoffice.org - famous office suite for linux, it's a multiple package
       + can easily uninstall or exclude their dependencies
       + linux package types
         + rpm - red hat package (.rpm), used by red hat, suse; to install use 'rpm' command
           + % rpm; # gives options
           + % rpm -i; # install command
           + % rpm -U; # update command
         + debian - ubuntu and other debian systems (.deb); to install use 'dpkg' command
         + both of these commands don't handle dependencies, cannot be used to search for packages and do not offer metadata about package
           + centos:
             + % ls -l vim-enhanced-7.4.629-5.el16.x86_64.rpm; # download vim enhanced package
             + % rpm -i vim-enhanced-7.4.629-5.el16.x86_64.rpm; # rpm install, it fails because of dependencies
         + yum (yellowdog updater modified), apt (advanced package tool) and zypper are introduced to overcome shortcoming
**** installing from RPM
     + redhat rpm:
       + -i : install; -U : upgrade; -e : erase; -q : query (used with other options)
       + % rpm -qa; # displays all packages installed on the system
       + % rpm -qa | grep <package>; # to determine whether package is installed or not
     + debian's dpkg:
       + --install; --remove; -l - to display installed packages
       + % dpkg -l | grep <package>; # to determine whether or not a package is installed
     + package managers
       + it needs repository, a repository is like a container containing packages, with their respective metadata
       + each vendor offers it's own repository (repo). packages are offered for download in HTTP or FTP
       + 'yum install' (red hat)/ 'apt-get install' (ubuntu)
       + redhat yum:         
         + % yum install lsof; # centos: package gives vast info about system, processes, network sockets, users using directories etc
         + '/etc/yum.repo.d/public-yum-o16.repo' - yum repo
       + ubuntu apt-get
         + % apt-get update; # update the local cache data sources (repositories) to reflect the latest changes, do update before any installation
           + '/etc/apt/sources.list' - file contains the source URLs for the packages, you needn't change this file unless you want to use your own apt repository
             + file contains types of packages those fully supported by ubuntu (main), unsupported open source packages (universe) and paid unsupported packages (multiverse)
**** making a local apt-get repo
     + used if you are managing a large number of ubuntu machines, and you need all of them share one local repo to save bandwidth
       + % apt-get install apt-mirror ; # install apt-mirror
     + /etc/apt/mirror.list - configuration file
       + % apt-mirror ; # starts mirroring process, first time takes lot of time. subsequent runs will consume much less time and can be automated by using cron jobs
     + /var/spool/apt-mirror - directory where packages are download, need atleast 50GB (path can be change in configuration file)
       + % ls -l /var/spool/apt-mirror/skel/archive.ubuntu.com/ubuntu
     + '/var/spool/apt-mirror/var/clean.sh' - delete obsolete packages
     + make it web reachable via HTTP or FTP (like symbolic link from your web directory to the packages directory)
       + % cd /var/www/html/
       + % ln -s /var/spool/apt-mirror ubuntu
       + % ls -ltr
     + all clients have to change their sources.list files to point to the local repo
     + you can automate system upgrades by using cron jobs, run 'apt-get update' before upgrade to ensure that you have the latest data
     + 'apt-get upgrade' or 'apt-get dist-upgrade' - upgrade command, later may delete packages that are not compatible so use it with care
     + '--yes' - use it for full automation, this will confirm all dialogs, use it with care
     + some updates require system reboot to be reflected like kernel upgrades
     + '--download-only' - to download the packages only and install them later after reviewing it
       + /var/cache/apt - packages directory
       + 'apt-get install /var/cache/apt/<package>' - to install/update specific package
       + 'apt-get autoclean' - to remove files that are no longer used
**** making local yum repo
     + /etc/yum.conf - configuration files
       + by adding 'proxy=http://proxy:8080' to /etc/yum.conf you can instruct yum to download and install through proxy
     + /etc/yum.conf.d - repositories themselves, you can add repo info to the same config file, but this is a bad practice
     + 'yum update' - to make system-wide upgrade, 'yum upgrade' does the same task, different meaning to 'apt-get update'
     + 'yum install' - install packages
     + 'yum update' - upgrade
     + 'yum remove' - uninstall packages
     + '-y' - auto-confirmation, discretion is advised
     + 'yum install http*' - will install httpd, asterisk before and after partial package name works
     + 'file:///' url points to the mounted filesystem of the DVD (not the live CD)
       + if needed, this can be further extended to serve other systems on the same network form the same DVD
       + use symbolic link in the web directory that points to the mounted DVD filesystem and update the appropriate client repo configuration to point to it
     + % ls -l /dev/sr0' - cdrom location (redhat dvd)
     + % mount /dev/sr0 /mnt/ - mount cdrom
     + % cd /mnt/
     + % ls -l
     + % cd packages; # lot of rpm packages
     + % cd /etc/yum.repos.d; # update repo
     + % vi media.repo; # new file
       + add '[DVD]
              name="DVD repository"
              baseurl=file:///mnt
              enabled=1
              gpgcheck=0
             '
     + % yum repolist; # check repo list
     + % yum --disablerepo=public_* install httpd; # temporarily disable public repo, install from DVD
     + % cd /var/www/html; # defaul web directory of httpd
     + % ln -s /mnt/ RedHatRepo; # make symbolic link
     + % service httpd start; # start httpd service
     + % iptables -vnL; # ensure firewall didn't disable http traffic
     + % iptables -F; # temporarily disable firewall
       + in browser https://<ip>/RedHatRepo - packages are visible
       + all m/c in network can use http service to install packages
     + local mirror
       + done using 'reposync' command, it's part of 'yum-utils' package
       + % yum -y yum-utils
       + % mkdir /repository; # should have sufficient space 50GB
       + % cd /repository
       + % reposync -r public_o16_latest -p /repository/; # to get repo rame vi /etc/yum.repos.d/public-yum-o16.repo, downloads packages locally
       + % cd /repository/public_o16_latest
       + % ls -l; # list of packages
       + % yum -y install createrepo; # install createrepo
       + % createrepo .; # create repo on directory; creates metadata 'repodata' directory
       + make a symbolic link from your web directory to the packages directory to make it web reachable
       + make appropriate changes to the clients repo configuration files to point to the new mirrored repo
**** tips and tricks
     + yum plugins
       + add extra features to yum and they are powerful
       + 'yum-fastestmirror' - makes yum auto choose the fastest connection to mirro
         + /var/cache/yum/timeshosts.txt - data is stored, you can force yum to recheck the fastest connection by removing this file
         + % yum -y install yum-fastestmirror
         + % yum update
       + 'yum-security' - enables yum to use the '--security' command line argument which makes yum ignores any packages other than the security related
         + % yum -y install yum-security
         + % yum --security update; only security related update
       + 'yum-presto' - decreases the download size when updating a package by downloading only the change between the installed and the new one (delta rpms)
         + % yum -y install yum-presto
         + % yum update
       + 'yum search <package>' - to search package
         + % yum search ssh; # list of packages that contains
       + 'yum whatprovides *command*' - some commands are part of packages that have different names, to search for them
         + % yum -y install scp; # scp not found because scp is not a package
         + % yum whatprovides *scp*; # look for openssh-client-*, this is the package that needs to be installed
         + % yum -y install openssh-clients
       + 'yum info <package>' - info about package
         + % yum info openssh-clients; # info about openssh
       + 'yum groupinstall group' - to install groups of packages like a desktop environment
         + % yum -y groupinstall "Desktop" "Desktop Platform" "X Window System" "Fonts"; # install group of packages
       + 'yum clean all' - to recreate cache (useful if you are behind proxy)
         + % yum clean all
         + % yum update; # it's re-downloading packages
*** shell scripting guide
**** introduction to shell scripting
     + saves time and effort. can be scheduled if use in Cron job
     + sh (bourne shell) is dominant one before bash (bourne again shell). other shells include ksh (korn shell) and csh (c-shell). default shell on centos and ubuntu is bash
     + csh used to make c programmers feel at home
     + % ksh; # starts ksh
     + if the task at hand is much more complex than to be solved by a bunch of shell commands, you can opt to use a fully fledged language like python or perl
     + if you are an emacs user, you can use following shortcuts to communicate with the shell
       + ctrl-e - jump to the end of the current line
       + ctrl-a - move to the line beginning
       + ctrl-p - brings the last used command
       + ctrl-n - brings the next used command
       + ctrl-r - lets you search for commands in history of the last used ones
     + 'set -o vi' - to enter vi mode at cli
     + 'set -o emacs' - to enter emacs mode at cli
     + process file descriptors (fd)
       + a process communicates with the system using channels called file descriptors (fd)
       + atleast 3 channels are available to a given process
         + stdin - standard input, for which the process accepts input, it is numbered as 0
         + stdout - standard output, to which the process directs any output produced, it is numbered as 1
         + stderr - standard error, to which any error messages are directed, it is numbered as 2
       + % ps -ef; # processes running in the system
       + % ls -l /proc/45163/fd; # to examine the current fd's used by a process by listing the files under the virtual directory /proc, where 45163 is process number
         + /proc - not real directory, it provides you important info about running processes
       + redirect standard output and standard error to a file using '>' and '>>'
         + % useradd user1; # add user1
         + % su - user1; # su user1
         + % find / -name core > output.txt 2>error.txt; # output to output.txt and error to error.txt
       + direct both error and output to the same destination using '&>'
         + % find / -name core &> output.txt; # both output and error to output.txt
       + instruct the process to take it's standard input from a file using '<'
         + % mail -s "output" root < output.txt; # write mail with output.txt as input
         + % mail; # check mail
       + inject the STDOUT of a command to the STDIN of another using the '|' (pipe)
         + % ls -l | grep install; # '|' is pipe
**** using variables
     + 'USER=joe' - example to assign a variable USER with value jeo, no space between '=' sign
       + % newvar="This variable contains text"
     + '$USER' - to call a variable or ${USER}, useful when using variable with literal text like ${ORACLE_HOME}/oraInventory
     + ''$HOME'' - will print $HOME
     + '"$HOME"' - will print home directory path of current user
     + you can add your environment variables in ~/.bash_profile or ~/.profile
       + % env; # lists env
     + 'cut' command
       + take STDIN, preform some processing on it before returning result as STDOUT
       + used to display parts of the input text, often used with delimited files like cs, and /etc/passwd
       + default delimiter is TAB character, but this can be changed using the -d command line argument
       + % cut -d , -f 1,3 < sample.csv; # to select the fields you want to display, use -f option followed by a comma separated list of numbers
       + % echo "This,Is,Cut,Example" | cut -d , -f 1,3; # prints This,Cut
**** the sort command
     + 'sort' command
       + sorts the lines of text give to it, type of sort: numerical or dictionary based
       + % sort -t , -k1,1 -n < sample.csv; # wll sort the lines of sample.csv in an integer based way, regarding the comma as a column delimiter and the key column is 1
         + '-d' - sort by dictionary
         + the key column can be more than one so we must specify that it will take only one column by inserting a comma and providing an end value k1,1
         + '-r' - to reverse order
         + '-u' - to print unique values only
         + '-b' - to ignore leading spaces
       + sort is usually combined with another filter command like 'cut' or 'uniq'
     + 'uniq' command
       + it returns the unique lines of a given text input
       + '-d' - to print duplicated lines
       + '-c' - to count the number of duplicated/non-duplicated lines
         + % uniq -u < sample.csv; # doesn't change anything, it has be sorted first
       + to use 'uniq' lines must be sorted first
         + % sort -t , -k1,1 sample.csv | uniq -u; # shows unique values
         + % sort -t , -k1,1 sample.csv | uniq -d; # shows duplicated values
         + % sort -t , -k1,1 sample.csv | uniq -dc; # shows duplicated values and no. of occurance
         + % sort -t , -k1,1 sample.csv | uniq -c; # will print the number of times a line has been entered in the sample .csv file
     + 'wc' command
       + word count to count words, lines and characters
         + % wc sample.csv # gives all in words(space as delimiter) lines and characters
       + '-l' - for lines
         + % wc -l sample.csv # gives lines
       + '-w' - for words
         + % wc -w sample.csv # gives words
       + '-c' - for characters
         + % wc -c sample.csv # gives characters
       + to start and stop service
         + % service httpd start; # starts httpd service
         + % service httpd stop; # stops httpd service
     + 'tee' command
       + to view the standard output of command while it's being written to a file
       + it's like a monitoring command
         + % find / -name *.log | tee output.txt; # will print the output to the screen and to output.txt file at same time
     + 'head' command
       + prints the first 10 lines of a file
       + '--lines=n' - will print only the specified number of lines, can be used as head -n
         + % head -5 sample.csv; # prints first 5 lines
       + '--lines=-n' - will print all lines in the file except the last n lines
     + 'tail' command
       + prints last 10 lines of a file
       + '--lines=n' - prints the last n number of lines in a file, can be used as tail -n
         + % tail -5 sample.csv; # prints last 5 lines
       + '--lines=+n' - prints all lines in a file starting with line number n
       + '-f' - will keep the file open, displaing any new lines added to it. This is typically used with log files
         + % logger "Hello"; # logger logs message to a main file in the server
         + % logger "This is a log message"
         + % tail -f /var/log/messages; # displays logs
       + '--pid=PID' - makes the command exit after the process which is writing to the file you're tailing exits.
         + useful so that you know if the process has exited or it's just not writing any output at the current moment
     + 'grep' command
       + searches for text in it's standard input and outputs
       + you can use regular expressions in pattern matching
       + '-c' - get the number of matches instead of printing them
         + % ps -ef | grep -c ssh
       + '-i' - ignore case when searching
       + '-v' text - matches if the text is not present
         + % ps -ef | grep ssh | grep -v grep; # removes grep ps from output
       + '-R' - perform a recursive search in current directory and all subdirectories
         + % grep -l root .; # it will output files that contain the text, searches in current directory
         + % grep -Rl root .; # it will search sub directories
**** basics of bash script
     + % bash script.sh; # to run bash script
     + '#' - comment
     + ';' - mutiples commands are separated in the same line
     + add '#!/bin/bash' as first line to make script self executable
     + 'echo'  - to print text to screen
       + '-e' - make it work like printf (interpret special characters like \t and \n)
       + '-n' - do not add newline character to the end of the line
       + % echo "Hello\n"
       + % echo -e "Hello\n"
       + % echo -n "Please enter your name: " # doesn't add new line
     + 'printf' - also prints text, allows to output special characters like tabs (\t) and add newline character (\n)
       + % printf "Hello\n"
     + 'read' - accept input from user followed by a variable
       + % echo -n "Please enter your name: "
       + % read user_input; # input to variable user_input
       + % echo "Hello " $user_input
     + arguments
       + arguments are interpreted by bash as $1, $2, $3 and so on
       + '$0' - holds the name of the script file
       + '$#' - contains the number of arguments passed to the script
       + '$*' - contains all the arguments passed at one
       + command line argument variables with special ones can be used to test whether or not the user has supplied the correct input if at all
         + and print a friendly usage message accordingly
         + sample usage code
           '#!/bin/bash
           if [ [ $# -eq 0 ] ]; then
             echo "Usage: " $0 "your name"
             exit 1 # failed exit
           fi
           echo "Hello " $1
           exit 0 # success exit' 
**** shell functions
     + shell functions
       + 'function function_name { code }' - syntax
       + sample code
         '#!/bin/bash
         function usage {
           echo "Usage: " $0 "your name"
         }
         if [ [ $# -eq 0 ] ]; then
           usage
           exit 1
         fi
         echo "Hello " $1
         exit 0'
       + usage is not restricted to shell scripting, you can also use them as an alias to your shell commands
         + you can add a function to your .bash_profile and use it as a command
         + 'function grepv {
            grep -v grep
           }'; # in ./bash_profile
         + % ps -ef | grepv | wc -l; # grepv is shell function
         + % 'alias ls="ls -ltr"'; # this is fine, but function can have more complex code
     + variable visibility
       + variables are global by default, but a function can make variable accessiblity limited to their own scope by using keyword 'local'
         + the variable retains its original value as soon as code execution leaves the function where the variable was created as local
     + decision making
       + sample code
         'id=`id -u`
          if [ $id -eq 0 ]; then # spaces needed before and after the square brackes
            echo "This script cannot be run as root"
          else # you can use 'elif' for else if condition
            echo "Welcome to our script"
          fi'
     + test command
       + '[ ]' in if condition is shortcut to /bin/test command
       + 'man test' - check for full list 
       + equal to 
         + '=' - string like '$user = 'Sam''
         + '-eq' - number like '$id -eq 1'
       + note equal to
         + '!=' - string like '$user != 'John''
         + '-ne' - number like '$id -ne 5000'
       + greater than
         + '-gt' - number like '$count -gt 0'
       + less than
         + '-lt' - number like '$limit -lt 100'
       + greater than or equal
         + '-gte' - number like '$count -gte 0'
       + less than or equal
         + '-lte' - number like '$limit -lte 100
       + file attributes
         + '-d directory' - directory exists
         + '-e file' - file exists
         + '-f file' - file exists and is a regular file (not a block device for example)
         + '-r file' - file is readable
         + '-s file' - file is not empty
         + '-w file' - file is writable
**** looping
     + 'for..in' - loop to iterate over a group of values and perform some commands on each one
     + sample code
       'for f in *.log; do # can accept a group of files by using globing through asterisk * or a question mark ?
          echo gzip $f # always good idea to add echo to print operations on screen
        done'
     + sample code
       'for i in user1 user2 user3; do
          echo $i
        done'
     + classic for loop is available in bash
       + sampel code
         'for (( i=0; i<$count; i++)); do # i is not preceded by a $ in the loop definition
            echo $i
          done'
     + while loop
       + continue to iterate as long as a specific condition is met, often used in reading strings such as user input or a text file
       + syntax
         'while [ [ condition ] ]; do
            code
          done'
       + sample code
         '#!/bin/bash
         input=""
         while [ [ $input != 'Y' ] ] do
           echo -n "Please enter Y to continue"
           read input
         done'
       + syntax for infinite loops, this is typically done in daemons that work in the background, listening fo ran event and acting accordingly
         'while true; do
            code
            sleep n seconds # needed so that you don't exhaust your machine resources
          done'
       + sample code
         '#!/bin/bash
          while true; do # 'true' is to continue infinitely
            echo 'date' >> timestamps.text
            sleep 1
          done'
       + ./<shellscript> & # '&' is to run the script in background
       + 'jobs' - lists running job
       + 'fg %1' - run job 1 in foreground; 'ctrl+z' to stop foreground
       + 'bg %1' - run job 1 in background
       + % tail -f timestamps.text; # file is updating
**** perl
     + fully fledged programming language that is must more powerful than bash
     + perl or python are designed for shell scripting
     + % yum install perl; # centos perl install
     + % apt-get install perl; # ubuntu perl install
     + sample code
       '#!/usr/bin/perl
        # this is comment
        $myvar = "Eduonix";
        print "$myvar\n";'
**** perl arrays
     + sample code
       '#!/usr/bin/perl
        @users = ("user1","user2","user3"); # array assignment
        print "$users[1]\n"; # scalar print
        $count = $#users;
        print "This array has $count number of users";'
     + sample code
       '#!/usr/bin/perl
        @users = ("user1","user2","user3", "user4"); # array assignment
        @admins = @users[1,2];
        print "The admins are $admins[0] and $admins[1]\n";'
     + sample code
       '#!/usr/bin/perl
        %user = ("username" => "johndoes", "password" => "changeme", "name" => "John Doe"); # hash assignment
        print $user{"name"}."\n"; # '.' is concatenation operation
        @slice = @user{"username", "password"}; # slice operation
        print "Username is".$slice[0]." and password is ".$slice[1]."\n";
**** perl script arguments
     + sample code
       '#!/usr/bin/perl
        print "What is your name? ";
        $input = <STDIN>; # input from user or other process via pipe '|'
        chomp ($input); # chop trailing spaces
        print "Hello ".$input."\n";'
     + sample code 
       + % ./perlinput username password
         '#!/usr/bin/perl
          $count = $#ARGV + 1;
          print $ARGV[0]."\n"; # print arguments
          if ($#ARGV == -1) {
            print "Usage $0 username\n";
          }
          if ($count < 2) {
            print "Usage $0 username password\n";
          }'
     + 'if' syntax
       + 'if (condition) {
            code if condition is true
          }
          elseif (condition) {
            code if above condition is false
          }
          else {
            code if all conditions are false
          }'
     + perl operators
       + equal to - string - 'eq' - $user eq 'Sam'
       + equal to - number - '==' - $id == 1
       + not equal to - string - 'ne' - $user ne 'John'
       + not equal to - number - '!=' - $id != 5000
       + greater than - number - 'gt' - $count gt 0
       + less than - number - 'lt' - $limit lt 100
       + greater than or equal - number - gte - $count gte 0
       + less than or equal - number - lte - $limit lte 100
     + perl loops
       + for syntax
         'for ($i=0;$i<10;$++) {
          }'
       + foreach loop syntax, works best with arrays
         'foreach $var($variables) {
            $var holds the current array item value
          }'
       + while loop syntax
         'while (condition) {
            code
          }'
       + infinite loop syntx
         'while (true) {
            code
            sleep n seconds
          }'         
     + sample code
       + % ./pse -ef | ./perforeach.pl ssh # this is like grep function
         '#!/usr/bin/perl
          @input = <STDIN>;
          foreach $line(@input) {
            if (index($line,ARGV[0]") != -1 && index($line,"perl") == -1) { # index is string search function
              print $line;
            }
          }'
**** python scripting - part A
     + python is generally more readalbe than perl, language is maintained in two streams: 2 (latest 2.7) and 3 (latest 3.5). Both are considerably different
     + it has it's own interactive shell, which is useful to test your commands before putting them in a script
     + python is said to have batteries included, means that it has got a lot of built-in functionality that make it independently robust enough to handle most tasks
     + it uses modules to encapsulate different types of tasks like 'os' module, 'time' module
     + 'sys' and 'os' modules are working with shell scripting and operating system in general
     + sample code
       + % python -v # python version
       + % python # interactive shell
       + p% print "username"
       + p% ctrl+d # exit python
     + sample code
       + % ./mypython.py username
         '#!/usr/bin/python
          print ("Please enter your name ")
          input = raw_input()
          print ("Hello " +  input)
         '
     + if condition syntax
       'if condition:
          code if true
        elsif condition:
          code if previous condition is false and this one is true
        else:
          code if all conditions are false
     + sample code
       + ./mypython.py username
         '#!/usr/bin/python
          import sys # importing sys module
          if (len(sys.argv) == 1): # len is length python function
            print "Usage " + sys.argv[0] + " username"
         '
**** python scripting - part B
     + lists are like arrays, a group of values saved assigned to one variable
       + 'listname = [val1, val2, val3]
     + tuples are the same as lists, but they cannot be modified
       + 'tuplename = (val1,val2,val3)'
     + dictionaries can be thought as associative arrays, they contain key value pairs
       + 'mydict = {key1:value1,key2:value2,key3:value3}'
     + python loops
       + for loop syntax
         'for item in item_sequence: # item_sequence could be any variable that can be iterated over, a list or a tuple
            code'
         + sample code
           + % ./mypython.py username password
             '#!/usr/bin/python
              import sys
              i = 1
              for c in sys.argv:
                print ("Command argument " + str(i) + " is "+ c)
                i = i + 1
             '
       + while loop syntax
         'while (condition):
           code'
       + infinite loop syntax
         'while (True):
            code
            time.sleep(n seconds) # import time module'
     + you can make python execute shell commands by using the subprocess module, provides call function which will execute the command you pass to it as parameter
       + sample code
         + % ./mypython.py
           '#!/usr/bin/python
            import sys
            import subprocess
            output = subprocess.call(["ls","-l"]); # subprocess takes inputs as lists
            print output
           '
     + shell scripting is a robust way to automate repetitive tasks
*** booting and shutting down
**** starting up and shutting down machines
     + bootstrap
       + bootstrapping is the process by which the system initializes until it is available to users
       + kernel is loaded into memory and starts execution, any startup script is executed 
       + bootstrapping process fails sometimes due to error in one of configuration (like /etc/fstab), damaged hardware, filesystem corruption
         + /etc/fstab - file responsible to mount files during startup
       + bootstrap process
         + code (firmware) saved in the ROM gets executed, it determines where and how to start the system's kernel
         + when the kernel loads, it checks for the system's hardware and starts the first and most important process, the init. The init process has always PID of 1 ('ps -ef')
         + filesystems are checked for any corruption, the system attempts to fix any recoverable errors it may find
         + after filesystems are checked and mounted, the system's startup scripts get executed by the init process
         + finally the login prompt/gui interface appears and the system becomes ready for users
     + kernel loading
       + is a program that gets loaded into the system's memory, it's loaded by a program called Boot Loader that executed from ROM
       + while loading, the kernel probes the attached hardware, and assigns an amount of RAM for itself, this part of memory will not be available to the user side
       + on linux systems, kernel can be found under '/boot'  (e.g. /boot/vmlinuz-3.8.13-118.e16uek.x86_64)
       + when kernel is loaded, it creates number of startup processes, most important one is 'init', having pid 1
       + other processes are created after that can be identified by having square brackets around them (like [kworker/0:1], / represents the processor number on which the process is running), these can't be treated as normal processes and should never kill it
         + 'ps -ef | grep "\[.*\]"'
**** startup daemons
     + startup daemons
       + after kernel is loaded, the startup daemons start to get executed by the init process, they are normal shell scripts that loads important system services like sshd, ntpd, httpd, dns, nfs ... etc
     + stage 1 - the bios
       + on proprietary systems (aix, hp-ux and sparc), the boot code is not stored in bios, it's stored in a much more powerful firmware, which has enough info about the attached hardware and can talk to the network on a simple level
       + on pc's the bios is responsible for executing the boot code, it's much simpler than proprietary m/c firmware
         + several types of bios, one for m/c another for video card and for scsi
       + bios config lets you choose the media from which you want the system to start and order by which it'll search for alternate media (or network) if first one fails
       + the boot media has it's first 512bytes checked to determine which partition contains the boot loader, the boot loader is responsible for loading the kernel
     + stage 2 - grub
       + grub is Grand Unified Boot Loader, it is the default boot loader in linux and unix systems running on intel processors
       + it reads configuration options from '/boot/grub/menu.lst' (on ubuntu and suse) and '/boot/grub/grub.conf' on red hat
       + configuration file options are
         + 'default=number' - which os/kernel to boot the system to. the list starts at 0. when new kernel is installed like through system upgrades, the old ones stay available for booting in the menu, so that you can choose to boot from them if the new one breaks the system
         + 'timeout=number' - sets the number of seconds the system would wait for a keyboard interruption before it loads the configured options
         + 'root (hd0,0)' - where to find the partition from which to load the system. the first disk and the first partition on the mc are defined as 0 and 0 respectivelly
         + 'kernel' loads the kernel from the specified path
       + grub command line interface
         + in can be invoked by typing 'c' in the GRUB boot screen
         + it provides a basic command line interface that has some useful grub commands, you can have a list of possible commands by typing <TAB> twice
         + one of the most useful cases of using GRUB cli is to boot OS that is not configured in grub.conf file, assuming OS is installed on the first partition of the second disk on the m/c this can be done as
           + 'root (hd1,0)'
           + 'kernel /vmlinuz-[select the kernel image you want] root=/dev/sdb2 [root specifies where the root(/) filesystem is located. sdb2 is disk 2, partition 2]'
           + 'boot'
           + example
             + type 'c' on grub boot screen
             + g% <TAB><TAB> # lists commands
             + g% root (hd0,0) # harddisk 1 and partition 1
             + g% chainloader +1 # to load bootloader on 1 sector of 1 disk
             + g% rootnoverify # prevent to mount file system
             + g% boot # boot command
         + other useful commands include 'find', it will search the system for regular files only (no directories)
         + on failing system you can find, for e.g. which partition the kernel is installed (vmlinuz), or where the root partition is ('/sbin/init')
**** booting a second OS
     + booting a second OS
       + with grub, you have option to install more than one os on the same m/c and select which one to use on startup
       + if second os you wnat is microsoft windows, it's wise to install it before linux, because window deletes grub after installation
       + some changes have to be made to grub to enable the system to boot into windows
         + 'rootnoverify(hd0,0)' - this forces grub not to try to mount the root partition
         + 'chainloader +1' - make grub load the boot loader from the first sector of the selected disk (disk 1 partition)
     + kernel command switches
       + you can interrupt grub loading, while in the timeout period, by pressing any key. you can then select the kernel you wish to boot from, and press 'a' to start adding command switches
       + '1' or 'single' - to enter single user mode
       + 'n' - the run level to where you want the system to boot
       + 'init=/bin/bash' - will let the kernel load '/bin/bash' instead of '/sbin/init' process. both of these options will allow you to access system as root without password. it will run only bash instead of init
       + 'root=/dev/sdxx' - lets the system boot to a different root partition e.g. 'root=/dev/sdb1'
       + 'ro' - boots the system in read only mode, strongly recommened when you want to perform 'fsck' on the disks before booting, 'fsck' should never be done on a read/write system, fsck is file system check
       + 'debug' - prints a more verbose output of the kernel loading status, useful when you want to troubleshoot a booting issue
       + 'selinux 0 or 1' - disables/enables selinux module, selinux is security module that is installed in linux by default
       + after selecting kernel on grub screen type 'a'
         + k% 1 # login's as single user
         + k% passwd # reset passwd, can be used when you forgot root passwd
         + k% init=/bin/bash # give bash prompt
         + k% passwd # to change root passwd
     + single user mode
       + used to give the administrator the most basic functionality of a systme, when it fails to boot, multiple logins are disabled only administrator (root) can login
       + this login done physically on the machine and not through the network because networking is disabled in this mode
       + an administrator can choose to enter single user mode by editing the GRUB boot arguments, by using the shutdown command or by using the 'telinit' command
       + you are allowed, in this mode, to open a shell as root without being prompted for a password. this is one way to reset the root password if lost or forgotten
     + startup scripts
       + these scripts are run by the init process, they are normal scripts that do some "housekeeping" to the system like cleaning '/tmp' files, they also prepare the m/c for use by doing tasks like setting the hostname, starting SSH daemon and configuring the network interfaces
       + they are place in '/etc/init.d' and symbolic links are made to them from respective, numbered directories like /etc/rc0.d
         + % cd /etc/init.d # traditional init scripts
         + % ls -ltr # see lot of scripts
         + % vim network # bash script executing network related operations
         + % cd ../rc0.d # rc0 is run level 0 and contains symbolic linked scripts to /etc/init.d, these is where scripts run, exists for each run level 0,1,2...
       + native systemd services files instead of traditional init scripts
         + % systemctl # list of current running services
         + % systemctl list-unit-files # list of all services (running, disabled, stopped and masked)
         + % systemctl start <service> # start service
         + % systemctl stop <service> # stop service
       + the init (or upstart) process ensures that the correct scripts are executed depending on the requested run level to which the system till boot
**** system run levels
     + system run levels
       + a run level is a specific state of a unix/linux system, they vary from one system to another but following are generally common
         + 0: halt, the system is shutdown
         + 1: single user mode
         + 2,3,4,5: networking is enabled
         + 6: system is rebooting
       + in linux, runlevel 3 is used for a non-gui session, while runlevel 5 is used for a gui-desktop session
       + default run level of the system can be configured in '/etc/inittab' file
       + you can move from on runlevel to another including shutdown and reboot, by using the 'telinit' command followed by the desired run level
       + 'telinit -q' - will force the system to re-read the '/etc/inittab' file
         + % vim /etc/inittab # change runlevel id:5 to id:3
         + % reboot # booted to text interface
         + % root # login and enter password
         + % ping 8.8.8.8 # ping dns server
         + % telinit 5 # boots into runlevel 5 (gui-desktop)
     + init process
       + startup scripts are used to both start,stop and restart daemons (e.g /etc/init.d/httpd start)
         + % cd /etc/init.d
         + % ./sshd stop # stop service
         + % ps -ef | grep ssh
         + % ./sshd start # start service
         + % ps -ef | grep ssh
         + % ./sshd restart # restart service
       + scripts are placed in '/etc/init.d' and symbolic links are located in '/etc/rc.*.d' where * indicates the run level at which the script should run
         + % cd /etc/rc5.d
         + % ls -ltr
       + init process looks at rc.d directories to deterine which scripts to run, depending on the configured run level
       + in an rc.d directory, the script name (symbolic link) starts with an S (start) or K (kill) followed by a number. e.g. K35smb. numbers ensure dependency between different services (if 'httpd' daemon started before the network service does, it will fail)
       + when transitionling from run level 3 to run level 5, init runs all the scripts that start with S in '/etc/rc5.d' in an ascending order passing 'start' as a command line argument to them
       + red hat implementation
         + init uses '/etc/rc.d/rc' script passing the run level as an argument
         + the scripts place an empty lock file in '/var/lock/subsys' with the same name as the daemon. presence of this file means that the service is up and running, this file is deleted when the script is called with the stop argument
         + 'chkconfig' - command is used to install, remove and manage startup scripts
           + 'chkconfig --add <script_name>' - will add the script to the configuration
           + 'chkconfig --level <script_name> on | off'  - will enable/disable an added script in the specified run level
           + 'chkconfig --del <script_name>' - will remove the script from the configuration
           + 'chkconfig --list' - will print all the configured startup scripts, works best with grep
         + '/etc/rc.d/rc.local' - which is run after all other boot scripts have finished execution, you can use it to add custom startup scripts
         + % ls -l /etc/rc.d/rc
         + % vim /etc/rc.d/rc  # go through init script
         + % ls -l /var/lock/subsys/ # lists of lock daemons
         + % chkconfig --list  # lists of scripts
         + % vim /etc/rc.local # custom local rc script runs after rc script
**** lab exercise: creating a custom daemon
     + lab exercie
       + % vim /opt/timed # convention to end name with d for daemon; /work/booting-and-shutting-dowm/timed
       + % chmod +x /opt/timed
       + % /opt/timed # test script before adding it to init script
       + % ctrl-c
       + % tail /tmp/timed.log
       + % vim /etc/init.d/time # script time; /work/booting-and-shutting-dowm/time
       + % chmod +x /etc/init.d/time
       + % /etc/init.d/time # test script time
       + % /etc/init.d/time start # runs in backgroup
       + % ps -ef | grep timed
       + % /etc/init.d/time stop # stop timed script
       + % ps -ef | grep timed
       + % chkconfig --add time
       + % chkconfig --list | grep time # check time script is added and config to run on 3,4,5
       + % ls -l /etc/rc0.d/ | grep time
       + % ls -l /etc/rc3.d/ | grep time # check symbolic link
       + % vim /etc/inittab # change reboot to run level 3
       + % reboot
       + enter login and password
       + % ps -ef | grep time # timed is running and parent process is 1 which is init process
       + % vim /etc/rc.local # to add script in the rc local file
     + ubuntu deprecated 'upstart' method of running scripts and follows same as red hat now
     + shutting down and rebooting the system
       + 'shutdown' - command is the safest way to halt a systme or make it enter single user mode
         + % shutdown --help # shutdown help
         + % shutdown -h 22:00 "This system is coming down shortly" # shutdown at 22:00
       + 'shutdom -h time "message"' - shutdown the system at specified time, sending the passed on message to the logged in users
         + 'shutdown +10 "message"' - shutdown the system after 10 minutes from now
         + '-h' - forces the system to sync filesystems, write any buffers in memory to the disk, '-n' ignores this step, its primarily used by the fsck command after repairing the root partition to ensure that the kernel does not overwrite the repaired superblocks with cached data
       + 'shutdown -r' - rebooting the system
*** user access control
**** user access control fundamentals
     + the ownershop concept
       + linux regards files and processes as objects, objects have owners and owners have almost unrestricted control over their own objects
       + the root account is the system administrator's, it can take ownership of any object
       + processes control the access to themselves internally, e.g. passwd command with a non-root user change his own account, but it won't let him reset another user's passwd
         + % cat /etc/passwd
         + % su - user1
         + % passwd # user1 can change his passwd
         + % passwd user2 # can't change user2 passwd, only root can specify a user name
       + filesystems control access to files and directories. filesystems are the only object type that implements the concept of "groups"
       + groups can contain a number of users, if the group has some permission on a file or directory, all group members have this same privilege
         + % ls -l /opt/sample.txt
         + % su - user2
         + % echo "sample" > /opt/sample.txt # permission denied
         + % logout
         + % usermod -aG user1 user2
         + % su - user2
         + % id
         + % echo "sample" > /opt/sample.txt # it will write to the file
         + % cat /opt/sample.txt
         + % ls -l /opt/sample.txt
     + filesystem security model overview
       + users and groups own files and directories, only owner user can change the permissions of his own file or directory
       + the filesystem views users and groups as number rather than textual names, e.g. root is identified by UID of '0' and wheel group as GID '10'
       + when an access attempt occurs from a user or a group, the filesystem will use the UID and/or the GID to grant or deny access
       + UID's and GID's are stored in '/etc/passwd' and '/etc/group' respectively, when a command like 'ls -l' is used to display ownership info, those files will be consulted to display the human-friendly name rather than the id
       + 'id' - command to display your own UID
       + 'id -g' - command to display the group
     + process security model overview
       + any process owner can send signals to it (e.g. 'kill -9'), he can also increase it's 'nice' value or decrease it's priority on cpu using 'renice' command
         + % vim proc.sh
           '#!/bin/sh
           while true; do
             sleep 1
           done
         + % nohup bash proc.sh &; # runs in background
         + % ps -ef | grep proc;
         + % renice +5 <process id>; # values ranges from -20 to +20
         + % renice -5 <process id>; # permission denied, only root can increase the priority
         + % kill <procee id>;
       + process or command when it runs, has following user and group id's
         + real - the account of the owner of this process
         + effective - this is same as real id's, but sometimes it is changed to enable a non-privileged user to access files that can be only accessed by root. e.g 'passwd' when run by a normal user to change this own password, the effective id becomes 0 to enable the user to make changes to '/etc/shadow' file. the process will check the real id of the user to grant or deny access accordingly
           + % ls -l /etc/shadow; # nobody can change this file, but will happend through effective id's
         + saved - it's used when a process is running with a elevated privileges needs to do some work temporarily, as a non-priviledged account. it saves the priviledge id to the 'suid' so that it can use it back as its effect id
**** the power of root
     + the power of root
       + the root account has id of '0', id '0' can do any operations on any other file or process
       + some tasks can only be performed by root account
         + setting the m/c hostname or ip address
         + changing the system's date and time
         + open network sockets on privileged ports (below port 1024)
       + the uid '0' process can even change it's own uid and gid, this happens when a normal user logs into the system, login process changes it's uid and gid to those of the user, this change cannot be rolled back
       + passwd should be atleast 8 characters long
       + using mix of numbers, special characters, small and capital letters is good but hard to remember and need to store it somewhere or type slowly, so it posses security risk
       + best approach is to use passphrases like "IhateSUSELinux10!", it's long has special characters contains numbers and easy to rember by you only
       + root passwd should be changed every 3 months, it's advisable to store root passwords, and maximum security measures should be applied to the place/software they're stored in
       + its not good idea to login as root
         + you lose the user accountability: who did what and when
         + most admin's do not apply password locking on root passwords, because this may completely lock the system with no direct solution to unlock the root account
       + recommended approach is to give administrators normal, unpriviledged accounts, when the root power is needed, they either 'su' to root or use the 'sudo' command
       + 'su' command
         + short for 'substitute' user
         + you can use it to change your current login session to a different user session or to root
         + root can su to any user without specifying the password
         + 'su user' - does not load the user's environment
         + 'su - user' - loads the user's environment
         + type 'exit' or 'ctrl+d' to exit from su
       + to disable root login, add in '/etc/ssh/sshd_config' (ssh config file) and add 'PermitRootLogin no'
         + % vim /etc/ssh/sshd_config; # add 'PermitRootLogin no'
         + % service sshd restart; # restart sshd service
         + disable only ssh login but never disable console login for root
**** delegating root powers with sudo
     + 'sudo' is used to specify specific commands to be run as another user or typically as root
     + 'sudo <command>' - for root
     + 'sudo -u' - command as user
     + 'sudo -g' - command as group
     + for it to work, the user has to be in the '/etc/sudoers' edited using command 'visudo', it ensures that the file contains no errors, and that no one else is editing the file at the same time
       + if 'visudo' shows error type 'e' when prompts 'what now?' to edit and fix error
     + user with sudo can continue running commands without being prompted for password for 5m
     + all 'sudo' commands are logged into a log file. you can use 'syslog' to forward the logs to a central log host
     + working with '/etc/sudoers'
       + the line that adds privileges to a user has the following format
         + 'user HOSTS=(USERS:GROUPS) COMMAND1,COMMAND2...'
       + you can also use command aliases, many of them are already defined in '/etc/sudoers' file
       + the 'HOSTS' part is used so that the 'sudouers' file can be shared across multiple machines
       + a user's groups can be denoted by %, e.g. %wheel is the wheel
       + optionally, you can add 'NOPASSWD : ALL || commands' to instruct sudo not to ask for passwords for specific commands or for all commands
       + if the commands you are delegating for users include those which can spawn other processes (like vi, vim and less) you should add 'NOEXEC:command' to avoid letting the use open a complete shell with the sudoed account
       + go through '/etc/sudoers' file
       + % su - user1
       + % sudo service ntpd restart; # ntpd - network time server
       + % sudo -k ; # mode where it asks for password every time
       + % logout
       + % visudo
         'user1 ALL=(root) /usr/bin/vim' # only vim exec privilege is provided
       + % su - user1
       + % vim
         ':! bash' # entering bash 
         b% id # still as user
       + % sudo vim
         ':! bash'
         b% id # now as root
       + % logout
       + visudo
         'user1 ALL=(root) NOEXEC:/usr/bin/vim' # doesn't run shell now
       + % su - user1
       + % sudo vim
         ':! bash' # bash shell denied
       + % logout
       + % visudo
         'user1 ALL=(root) NOPASSWD:/usr/bin/vim'
       + % su - user1
       + % sudo -k
       + % sudo vim # doesn't ask passwd anymore
       + % logout
       + % visudo
         'user1 ALL=(root) ALL' # access to all command with root permissions
       + % su - user1
       + % sudo -i # enter passwd, gives new shell
       + % whoami # is root
       + % logout
       + % logout
       + % tail /var/log/secure # log file, prints very verbose logs
       + % sudo tail /var/log/auto.log # log file in ubuntu
**** system access
     + system access
       + they are user accounts used to execute system services, idea is to use them instead of using the root account for such tasks
       + they are protected from being used for login, by placing an asterisk instead of password hash in the shadow file, also by settings the default shell to '/bin/false' or '/bin/nologin'
         + they donot have home directory
       + their uid's are generally under 100
       + % sudo vi /etc/passwd # you can see service account like daemon, bin, sys, sync, games, man, lp, mail ...
       + % sudo adduser --system --no-create-home --uid 99 time; # adding system user 'time'
       + % vi /etc/passwd # user time is created as system account
       + % ls /home/time # not time home directory
       + system account are exempted from passwd aging policy as they aren't used for login
*** controlling processes
**** process control fundamentals
     + process
       + representation of running program
       + used to monitor and control the program's access to system resources like cpu, memory and i/o
       + the kernel allocates memory for each process, typically measured in "pages", the location of this address space (memory or swap) cannot be determined as unix combines both in virtual memory (memory + swamp)
       + important info about process recorded by kernel - owner, the state (running, sleeping ... etc), execution priority (nice value), the resources usage (files, network sockets ... etc)
     + identification
       + the kernel assigns a unique identifier to each process call PID
       + when the process demands a new program (process) to be started, it clones itself first, then the clone replaces the initial program with the desired one. the original process here is called parent and it's id is referred to as parent ID or PPID
       + the ppid can be used to trace the source of a running process, it can also be used to track the behavior of a given process (how many and what processes it is spawning)
       + % ps aux | head # you can see PID
       + % ps -ef | head # you can see PID spawning from PPID
**** ownership
     + ownership
       + the real UID (RUID) is the user id of the process owner
       + the effective UID (EUID) is the id of the user that the process is using temporarily to do some tasks. this is often the root id (0), this behavior can be found in programs that have setuid like passwd
       + the group id 'gid' is treated the same as the 'UID', with 'GID' and 'EGID'
       + the gid is not used most of the time, instead 'EGID' and the supplementary group list determine the process access permissions, because a given process may need to use one of the supplementary groups to be granted the required access level
       + % su - user1
       + % id; # uid, gid, groups - supplementary group
       + % groupadd admin; # creating group admin
       + % usermod -aG admin user2; # add user2 to group admin
       + % su - user2
       + % id; # you can group 'admin' in groups
     + cpu priority
       + the kernel internally determines how much cpu time a process is allowed to consume
       + the admin can set this value manfully, it is called the nice value, it ranges from -20 (highest priority) to 19 (lowest priority)
         + % top; # see pid, NI-Nice value
       + default, child process inherits its parent's nice value
       + a normal user can use the renice command to lower the priority of his own process (positive value), but he cannot use it to increase it's priority even to it's original value, the superuser can place any nice value on any process on the system
         + 'renice value pid'
         + infiniteloop.sh
           '#!/bin/bash
            while true; do
            sleep 1
            done'
         + % ./infiniteloop.sh &
         + % top; # NI=0 (nice value)
         + % renice 5 <pid>; # NI=5
         + % renice 0 <pid>; # permission denied
         + r% renice 0 <pid>; # renice to lower value as root is allowed
       + the nice value only controls the cpu time assigned to the process and not the utilization of memory or i/o
       + the nice command is used to start a process in the specified nice value
       + the most common use of the nice command is when the system is under high load and you want to start a shell to investigate the issue. starting a normal shell will cause a lot of logging
         + 'nice -n value /path/to/command'
         + % nice -n -10 bash; # will start a bash shell in a higher priority than other processes
**** process spawing and termination
     + process spawning and termination
       + a running process can launch a new child process by using the 'fork' system call, this creates an identical clone of the running process, but has some differences
         + a different and unique pid, zero cpu and memory consumption (initially) and empty list of pending signals
       + the child process 'exec' command (system call) to execute the new program
       + when the child process dies first, the parent process issue the 'wait' system call to notify the kernel that the child process is ready to vanish, it also receives the exit code that indicates why and how the termination occurred (0 means normal)
       + if the parent process dies first, the child process becomes orphaned, in this case, the 'init' process becomes the parent
       + % cd /opt/
       + % nohup ./infiniteloop.sh &; # infinite loop program, nohup - not kill the process on logout
       + % ps -ef | grep infini; # parent pid (ppid) is 10876
       + % logout
       + r% ps -ef | grep infini; # login as root, ppid is transferred to init (ppid)
     + communicating with a process
       + a running process can receive signals from the kernel, the user or other processes as a means of communication
       + the process may respond to the signal (if programmed to) or the kernel will act on behalf of the process and respond to the signal
       + most familiar signals
         + num:name:shortfor:sentwhen
           1:SIGHUP:Hang-Up:The controlling terminal has been closed
           2:SIGINT:Interrupt:Break key is pressed (like ctrl-c)
           3:SIGQUIT:Quit:The user wants the process to terminate and provide a core dump file. Sent by ctrl-y or ctrl-\
           9:SIGKILL:Kill:Terminate immediately. This signal cannot be ignored and the process does not perform any clean up before exiting
             + SIGKILL (kill -9) is not recommended, as it need to kill immediately programms will not be able to catch this signal and do cleanup before terminating
           11:SEGV:Segmentationfault:The process tries to access virtual memory that does not belong it to. The process is terminated and core dump is provided
           15:SIGTERM:Termination:The process is asked to terminate. The signal can be caught and ignored, allowing the process to perform a clean shutdown
       + in shells like csh, the HUP signals are ignored automatically, that is, you can run a program in the background and it will continue to run after you logout of the shell. in shells like BASH, this has to be done by placing 'nohup' before the command
**** terminating a process
     + terminating a process
       + use the kill command to terminate a process, 'kill' command sends a TERM signal by default, but it can be used to send any other signal as an argument to the command
       + the 'TERM' signal does not necessarily kill a process because it can be intercepted by the program and ignored
       + the 'SIGKILL' signal is often enough to terminate a process, in some cases a reboot is required to kill a process which is waiting for a response that will never come from a disk or network device
       + you can use 'killall process_name' to kill all the processes associated with a program, beware that in unix the same command will kill all the processes initialized by the current user. if it's root, the system will halt immediately
       + the 'pkill' command can be used to kill a process by it's name
     + process modes
       + S - the process is sleeping, it's waiting for something or a resource
       + R - the process is running or runnable, it is being executed or can be executed whenever the CPU time is available
       + Z (defunct) - the process is supposed to be dead but it's not (zombie), normally it wil die shortly, it not a reboot may be required
       + T - the process is suspended (traced), this can be obvious if you pressed ctrl-z to pause a running command
       + % top; # "S" - process state
       + % cd /opt
       + % ./infiniteloop.sh
       + % ctrl-z; process stopped
       + % top -pid <processid>>; # "S" is T (suspended)
     + ps command
       + is the defacto command of process monitoring
         + 'a' - show all processes not just the current user's
         + 'u' - user oriented output
         + 'x' - show also processes that were not started from the terminal
         + % ps aux; # RSS - total virtual memory the process is using
         + 'l' - instead of 'u' to print the long version of the output, this prints the uid as a number rather than the username
         + % ps lax; # longer output
         + 'ef' - similar output can be obtained by using this switch
         + % ps -ef; # shorter output
     + real time process monitoring
       + 'top' - command offers a real time view of the processes running on the system with many useful information like the amount of CPU and memory used, output is sorted by the cpu, but you can choose another sort field
         + % top
       + you can use top command to dynamically renice processes
       + another command that extends 'top' (third party) is 'htop'
         + http://hisham.hm/htop/index.php?page=downloads
       + 'top' is not a priviledged command, it can be run by other users than root
       + the default refresh interval is 3 sec, this can be modified by using the '-d' option
**** using the /proc filesystem
     + using the /proc filesystem
       + it's virtual filesystem that is created on the fly when the system boots
         + % ls -l /proc
       + completly destroyed when system shutdown's
       + contains useful info about the processes currently running
       + you can use 'ls' to list the files and directories. 'cat' to show file conctents just as you deal with any other filesystem
       + given a process pid, you can access it's properties in '/proc' like this 'ls -l /proc/<pid>'
       + some useful directories
         + 'fd' - for the file descriptors used by the process (STDIN, STDOUT, STDERR and any files currently being written too, like log files for example)
         + 'cmdline' - command line that the process was started with
         + 'cwd' - a symbolic link to the process working directory
         + % ps -ef | grep http
         + % cd /proc/<httpps>
         + % ls -l
         + % ls -l fd; # file descriptor; 2->stderr is redirected, process can have any no. of descriptor and can be redirected
         + % ls -l cmdline
         + % cat cmdline
         + % cat cmdline && echo; # echo prints new line
         + % cd cwd; # working directory of the daemon
         + % ls -ld cwd; # symbolic link
     + tracing a process
       + 'strace' - command to monitor the system calls that a process makes on a very level
       + 'strace' is useful when you want to troubleshoot a hanging or a frequently crashing process, because you will know exactly what was the last thing the process was trying to do before it crashed or kept on waiting for
       + '-f' - to trace child processes (forked) as well
       + '-e' - can be used to direct the output to a file, this is useful when you want to monitor a process that will take a very long time and you want to analyze it's behavior over that long period
         + % strace -p <httppid>; # tracing httpd daemon
         + % ctrl-c
         + % ps -ef | grep ntp; # ntp - time server, get pid
         + % strace -p <ntppid>
         + % strace -f -e strace.out -p <ntppid>; # traces all the child processes and write output to strace.out
*** the file system
**** the file system fundamentals
     + filesystem
       + a representation of storage and other objects on the system
       + in linux, everything is a file: regular file, devices, drivers and even processes
       + the kernel provides an abstract layer for dealing with different filesystems consistently, e.g you work with files on the local m/c as well cifs (samba share) and nfs the same way
       + popular filesystems: 
         + ext3 and ext4 for linux
         + zfs for solaris
         + jfs for aix
         + iso9660 for dvd-roms (also used when mouting iso files)
         + ntfs or fat for windows
       + file names and paths
         + any linux filesytem starts at the slash '/' also called root
           + % ls -l /; # root file system
         + '/etc/sysconfig/network-scripts/ifcfg-eth0' - example path
         + linux kernel limitations on pathnames
           + each segment in the path should not be more than 255 characters 
           + whole path length cannot exceed 4095 bytes
         + filenames that contain spaces can be represented either quoted with double quotes or have the space escaped by backslash
           + % cd My\ Documents; # backslash
           + % cd "My Documents"; # within quotes
     + mount points
       + a device must be mounted in order to be accessed by the system
       + 'mount /path/to/device /mountpoint' - mount syntax
         + % fdisk -l; # 
         + % mount /dev/sbd1 /mnt;
         + % cd /mnt
         + % ls -l
         + % df -h; # check disk space
         + but disk is not persistent on reboot, to be persistent edit fstab file
         + % vim /etc/fstab
           '/dev/sdb1  /mnt  ext4  default 0 0' # 0 0 - not to check fsck
         + % mount -a; # mount fstab, also point out errors on mount, good to check before reboot           
       + mounts points are stored in '/etc/fstab', this allows the system to run 'fsck' on the filesystems when booting and to mount devices found in this file automatically on startup
       + 'unmount' - to detach a filesystem, there must not be any processes that use the filesystem to be successfully unmounted
         + % fuser -c /mnt/; # gives pid that still accesses the mount
         + % ps -ef | grep <pid>; # give process command that using the mount
         + % yum -y install lsof
         + % lsof /mnt/; # gives processes that using the mount file system
         + % kill <pid>; # kill any pid's that access /mnt, if other user, you will request him to kill, using 'kill' without arguments first then 'kill -9'
         + % unmount /mnt; or
         + % unmount /dev/sdb1; 
       + '-l' - argument can be added to unmount to perform a lazy unmount, remove the mount point the directory tree, device is not completely unmounted until all processes using the device have exited
         + % unmount -l /mnt; # use it only when there is no other option
       + '-f' - natively available, but it cannot be used on modern filesystems like ext3 and ext4 because they are journaled filesystems       
**** important directories
     + most important system directories that you should be cautious when dealing with them
       + '/etc' - contains sensitive configuration files
       + '/bin' - system utilities and commands like 'ls','cat' ... etc
       + '/sbin' - commands that are intended to be run by the superuser like 'mount' and 'mkfs'
       + '/dev' - device files like disks
       + '/lib' and '/usr/lib' - shared libraries, often '/lib' has symbolic links to '/usr/lib' to facilitate updating a library without breaking dependent applications
       + '/usr' - contains various programs and libraries, it also contains the manual (man) pages
       + '/var' - contains variable files, that is files that change a lot, like log files and spool directories, it is advised to place the /var on separate filesystem
       + '/home' - it is not strictly a system directory, it is the location where user's home directories are placed, it is also advised to be placed on a separate filesystem
       + 'man hier' - displays a much more detailed filesystem list
     + linux can recognize only seven types of file, no matter if it's real physical file, a device or a virtual file
       + regular
         + most common file type in linux, contain streams of bytes with no special order
         + text files, binary executables, images and audio files are all examples of regular files
         + they can be accessed sequentially and randomly
           + sequential access - the file is being accessed a certain group of bytes at a time, in sequence e.g 'cat' command on a text file
           + random (direct) access - you can jump to any point in the file and start reading from this point forward or backward e.g. 'vi' to jump to a specific line number in a text file
       + directory - directories and hard links
         + directories contain pointers to the files inside them
         + files info are stored in their directory and not in the files themselves, you must have write permission on a given directory to be able to delete files underneath it, otherwise you can't delete a file even if you have full permissions on it
         + a directory can have more than one reference to the same file, these are called 'hard links'. a hard link is a file is treated just the same as the original file, it cannot be created on other filesystme
           + 'ln <src> <dst>' - to create hard link
           + 'ls -l' - displays the current number of hard links a given file has
           + deleting hard link will not delete original file
         + hard links can be deleted using the 'rm' command
         + directories can be deleted using 'rm -r' or 'rmdir' for empty directories
       + device files
         + in linux everything is a file, including devices
         + device files are used as a means of communication b/w the system (kernel) and the physical hardware device
         + device files receive requests from the kernel and redirects it to the device driver which in turn sends it to the physical device and vice versa
         + if the device file is a charactor one, buffering is done by the device driver. 'character device files' are used with devices that do not need to transfer large amounts of data. e.g. tty(terminal), pseudo-devices like '/dev/null/' and '/dev/zero'
         + character device files are denoted by 'c' in the 'ls -l' output
         + 'block device files' rely on the kernel to do the buffering, they deal with data in large chunks. e.g disks. 
         + block devices are denoted by 'b' in 'ls -l' output
       + unix domain sockets
       + named pipes
       + symbolic links
**** device file numbers
     + device file numbers
       + device files have a major and minor numbers
         + the major number informs the kernel about the physical location of the device on the system, e.g 8 as a major number represents a disk device
         + the minor number is totally interpreted by the device driver itself, e.g 1 in '/dev/sda1' represents disk partition 1
         + % ls -ltr /dev/sda1; # major number 8 and minor number 1 (partition 1)
         + % ls -ltr /dev/sr0; # major number 11 and minor number 0
         + % ls -ltr /dev/sda; # whole disk, major number 8 and minor number 0
       + 'udevd' - daemon is responsible for discovering new devices and assigning device numbers to their files, it also deletes them according to kernel notifications of hardware changes
         + % cd /dev
         + % ps -ef | grep udevd
     + unix domain sockets
       + they represent ways to allow proceses to connect to each other on the same system
       + don't confuse them with network sockets, these inter-process connections on the same m/c that don't involve networking
       + they appear like files but they cannot be accessed except from the connected processes
       + 'syslogd' - daemon which collects system logs, e.g of a process using unix sockets
       + '/proc/PID/fd' - you can view a socket file by naviagting to a process directory that uses a socket
       + % cd /dev
       + % ps -ef | grep *syslog; # gives PID
       + % cd /proc/PID/fd
       + % ls -l; # flashing filename is socket (num 0), reading from socket
     + named pipes
       + they serve the same purpose of unix sockets, connecting processes
       + named pipe are like shell pipe (|) but it's bidirectional
       + they are also referred to as FIFO pipes
       + 'mkfifo' or 'mknod' - command to create named pipe, once created you can view it on the filesystem like any other file
       + e.g of named pipes is to share terminal windows
         + in first terminal create a pipe using 'mkfifo pipe'
         + then instruct the terminal to redirect the output to the pipe using the script command - 'script -f pipe'
         + one the second terminal cat the pipe 'cat pipe'
         + now everything you type or see on the first terminal is automatically in the second one
         + % mkfifo pipe
         + % ls -l; # name pipe is created; file type is 'p'
         + % script -f pipe
         + t2% cat pipe # on terminal 2
     + symbolic links
       + you regard them as shortcuts to files and directories
       + they are also called as soft links to differentiate them for hard links, in contrast to those, soft links are not direct references to the files
       + 'ln -s <src> <dst>' - creates a symbolic link
         + soft link we use '-s' and for hard link we don't use '-s'
       + they can cross filesystem boundaries (unlike hard links)
       + one of the prominent uses of symbolic links is in the '/lib' and '/usr/lib' directories, they contain symbolic links with general library names (without the version). this way, library files can be updated with new ones without breaking the applications that are currently using them as those applications point to the general library name (the link)
       + they can be deleted with rm
**** file deletion with rm
     + file deletion with rm
       + 'rm' - to delete all types of files, asks for user confirmation
       + 'rm -f' - can be overridden
       + 'rmdir' - to delete an empty directory
       + 'rm -r' - to delete a directory that contains files
       + '--' - switch to delete files/directories that contain special characters
         + % rm -- -f; # -f is file here
       + '-i' - if you use globing, use this switch to avoid deleting files by mistake
     + file aspects
       + in linux a file has 9 bits controlling who can read, write or execute it. in addition, it has another three bits that control how the file will get executed called "mode" bits
       + a file also contains 4 bits which define its type that cannot be changed
       + 'chmod' - command to change the 12 bits of permissions, when used by the file owner or superuser
       + 'ls -l' - command to see file permissions
       + 'ls -ld' - command to see directory permissions'
       + file permissions are controlled by 9 bits that control read, write and execute rights for the owner user, owner group and everyone else respectively (3 bits per each)
         + % ls -l data.txt; # -rw-r--r--, first '-' is type, can't be changed, next 3 bits (rwx) for owner, next 3 bits (rwx) for owner group and last 3 bits (rwx) for everyone else
         + % chmod 755 data.txt; # user('u')=rwx; group('g')=r-x; others('o')=rwx
         + % chmod u+x data.txt; # add 'x' permissions to users
         + % chmod +r data.txt; # add 'r' permissions to all
         + % chomod o-x data.txt; # remove 'x' permissions to others
         + % chmod -x data.txt; # remove 'x' for all
         + % chmod g+rx data.txt; # add 'rx' for group
         + '-R' - switch to make chmod work recursively on all files and directories
       + coderstoolbox.net - online utilities
**** what do permissions offer ?
     + what do permissions offer
       + read permissions - file can be read and copied
       + write permissions - file can be modified
       + execute permissions - file to be self executed either directly (binary file) or by an interpreter like script files (bash, perl and python)
       + read permissions on directory - allows it to be listed for its files, but alone it does not allow directory access
       + write permission on directory - allows directory to be modifed, like file creation, deletion and renaming
       + execute permission on directory - allows directory to be accessed, but you cannot list files. for this reason, directories are often set with read and execute permissions
     + other file attribute bites
       + we covered nine of twelve bits of file attributes, the remaining 3 bits are
         + 4000 and 2000 represent the 'setuid' and 'setgid' bits
           + when set on executable files, they are run in the account id of the owner user or group rather than the context of the user who executed them
           + when 'setgid' bits added to a directory, all new files created under it become owned by the owner group of the directory instead of the owner group of the user who created it, this is useful in directories that are used by multiple users
             + % touch sample.txt
             + % chmod g+s sample.txt
             + % ls -l sample.txt
             + % chmod 4755 sample.txt; # change via octal
         + 1000 represent the 'sticky bit', when set on a directory you cannot delete or rename a file inside it unless you are the owner of the directory, the file or you are the superuser. this is typically the case with '/tmp' directory, where anyone should be allowed to create files, but only the owner of the file can change or delete it
         + setting the remaining 3 bits using chmod is done the same way as standard permissions. e.g. 'chmod 1777 /tmp' will set sticky bit on '/tmp'. similarly 'chmod g+s /mydir' will set 'setgid' bit on 'mydir' (s for setuid/gid and t for the sticky bit)
     + listing file attributes (ls)
       + '-l' - list the file attributes, add '-d' to view directory attribute instead of listing their files. the output is as follows
         + file type (regular, device ... etc) on the first field
         + file permissions on the next nine fields. they are represented as 'rwx' for read, write and execute. if the setuid is set, the 'x' in the owner part is replaced with an 's', if the setgid is set, the 'x' for the group will be replaed with an 's'. if the sticky bit is set, the 'x' in the "others" part is replaced with a 't'
         + a number representing the link count of the file, it counts only the hard links of the file and not the symbolic links. directories always have two hard links: the link from the parent directory (..) and the link from the current directory (.)
         + the owner user and owner group of the file respectively. the filesystem views those as numbers, but consult the appropriate database (/etc/passwd, LDAD...etc) to resolve it to a name, it will print them as numbers if the names could not be found
         + size of file in bytes
         + last modification date
         + filename
         + useful command switches for 'ls'
           + 'a' - list hidden files/directories
           + '-t' - sort by the last modification date and time
           + '-r' - reverse the sorted list (-tr will make the newest files at the bottom)
           + '-h' - print the file sizes in human readable format
           + '-R' - lists files recursively
**** changing file ownership    
     + changing file ownership
       + 'chown' and 'chgrp' - commands to change ownership for owner user and owner group, user must be the owner of file or group member to change ownership
       + '-R' - to make it recursively
       + 'chown user /path/to/file' - syntax
       + 'chown user:group /path/to/file' - to change the user and group ownership in one go
       + using globing with 'chown' is not recommended because it may match undesired files, e.g 'chown johndoe .*' to change all hidden files owner in the current directory will also match the '.' and '..' effectively changing the ownership of current and parent directoreis
         + 'find . -type f -name ".*" | xargs chown johndoe' - use this syntax
     + setting default permissions (umask)
       + 'umask' - used to set the default permissions that files and directories are granted when they are created
       + every process has it's own 'umask' value to control the permissions of the files it creates throughout it's lifecycle
       + since the shell is a process, it has it's own 'umask' value that influences the file permissions that the user creates in his session
       + the 'umask' works by subtracting permissions
         + umask 000 is 777-000 = 777
         + umask 022 is 777-022 = 755
       + the umask for files is '666-umask' while directories have '777-umask'
       + 'umask octet' - syntax
       + it can be put in '.bash_profile' to make it the default value for each session
         + % umaks; # shows default permissions
     + access control lists (acl)
       + traditional permissions model for linux has some shortcomings, e.g. if i want a user that is not in my group to read a file that i created, yet i don't want the file to be word readable just to let that user have the required access? that's why acl was introduced
       + they are supported by the filesystem so they must be turned on while mounting by using '-o acl' as a mount option
         + % df -h; # list mounts
         + % umount /mnt/; # unmount
         + % mount -o acl /dev/sdb /mnt/; # mount with acl enabled
         + % useradd user2
         + % su - user1
         + % touch /opt/securefile
         + % ls -l /opt/securefile; # owner is user1
         + % chmod 660 /opt/securefile
         + % setfacl -m u:user2:r /opt/securefile
         + % logout
         + % su - user2
         + % cd /opt/
         + % ls -l
         + % cat securefile; # can read file
         + % su - user1
         + % chmod 600 /opt/securefile; # removed read permissions
         + % getfacl /opt/securefile; # get acl info
         + % su - user2
         + % cat /opt/securefile; # can't read file now as chmod overtakes acl
     + acl deals only with the nine permission bits of files setuid, setgid and the sticky bit are not implemented here
     + 'setfacl user:username:permissions' - syntax of setting acl
     + 'setfacl -m u:johndoe:r /path/to/file'
     + 'setfacl -m g:admin:rx /path/to/file'
     + '-R' - to make recursive permission changes
     + 'getfacl /path/to/file' - to view the acl of a file or directory
*** adding new users
**** User Management Part A
  + /etc/passwd file
    + It's the primary repository of users on a standalone system, it may be replaced by a centralized LDAP server in large environment
    + The file contains seven fields separated by colons:
      + login name
      + password placeholder
      + UID
      + GID
      + Human friendly information (real name, phone ... etc)
      + Home Directory
      + Login shell
    + % vi /etc/passwd
    + login name
      + if an NIS is used, login name is limited to 8 characters long
      + don't use ':', new line character
      + requires first character to be lower case or underscore
      + best practice
        + should be no more than 8 characters for backward compatibility
        + should be all in lower case for consistency
        + it's wise to use a naming convention like "first.last"
    + password placeholder
      + password field in the /etc/passwd, real encrypted passwd is stored in /etc/shadow file
      + you can opt ot use /etc/passwd for storing passwds (not recommended) using pwuconv command. If you want to revert to /etc/shadow use pwconv
**** User Management Part B
   + password placeholder
      + linux supports a no. of encryption algorithms, they can be set in /etc/login.defs file, together with the password length
        + look for "UID_MIN/UID_MAX/GID_MIN/GID_MAX" and description
        + look for "ENCRYPT_METHOD SHA512"
        + look for "PASS_MAX_DAYS/PASS_MIN_DAYS/PASS_MIN_LEN/PASS_WARN_AGE" and description
      + If you are manually editing the /etc/passwd and /etc/shadow files to manage users (not recommended), you must put a star in the passwd placeholder to prevent the user from logging in unless a password is provided. Leaving the password filed empty allows the user to login without entering a password
        + % vipw; # to edit /etc/passwd file
        + % vipw -s; # to edit /etc/shadow file
        + If password filed is empty then need to configure /etc/ssh/sshd_config to enable password
          + % vim /etc/ssh/sshd_config
          + enable "PermitEmptyPasswords yes"
            + if enable "PermitEmptyPasswords no"
            + % sshd restart; # restart sshd
            + % ssh <user>@<ip>; # now you can login without password
            + % id -a; # info about <user>
      + The encrypted string that starts with $ means that it was not encrypted using DES. For e.g, $1$ means and MD5-based algorithm was used, while $6$ indicates a SHA512 algorithms
      + If an exclamation mark is placed before the password string this means that the account is locked
      + If two users choose the same password, that does not mean that you will find the same encrypted string because Linux adds a "salt" string to the password before encryption
        + % useradd user1; # add user user1
        + % echo abc123 | passwd user1 --stdin; # add passwd to user1
        + % useradd user2; # add another user user2
        + % echo abc123 | passwd user1 --stdin; # add same passwd to user2
        + % vi /etc/shadow; # user1 and user2 hash passwd are not same
**** UID - User Identification
   + UID - User Identification
     + users are defined by their names only for the benefit of users, all applications and filesystems use the UID to identify users on Linux
       + % id
       + % id chmod
     + the root has UID of 0
     + Linux may create fake accounts to be owners of daemons and services like daemon, bin, main...etc
       + % vi /etc/passwd; look for user accounts
     + Although the system permits having multiple users with the same UID, it is highly not recommended, especially for the root account
       + % useradd -o -u 0 systemadmin; # created systemadmin
       + % su - systemadmin
       + % id; # user didn't change from root
       + % userdel systemadmin; # can't delete this account
       + you have to delete in /etc/passwd
     + It is advised to have the unique UID's across the entire network. This ensures that every person has the same UID on any system. Such a control will mitigate potential security vulnerabilities when sharing files, like through NFS for example
     + As the number of connected systems gets higher, it will be hard to keep this unique UID control; so it's advisable to use a centralized login system like LDAP
   + GID - group identification
    + Used to identify groups by number
    + Only the primary group is listed
    + The root group GID is 0
    + System users are also assigned to groups
    + They are mainly used to share files among users
    + If setgid is used, any file created in the directory will bear the group id of this directory instead of it's own
   + GECOS "General Electric Comprehensive Operating Supervisor"
    + brand of mainframe computers
    + field contains human readable, personal information about the user
    + you can view info about a user by using the 'finger' command
      + % finger <user>; # display useful info
      + % vi /etc/passwd
        + add "username,address" in GESCOS field
    + you can use the 'chfn' to update this info (will not work on LDAP)
      + % chfm; # change user info
      + enter name, office, phone
      + % finger root
      + % vi /etc/passwd; # info is updated
    + if you want to add it manual, make sure you separate the fields by commas(,). Of course you'd do this as root
  + Home directory
    + default directory to which the user is put upon logging in
    + defautls to /home followed by a directory that has the same name as the user's. /home can be changed in /etc/default/useradd
      + % vi /etc/default/useradd
      + you can change /home and shell
    + it contains environment files like .bash_profile and .bash_rc
    + sometimes administrators create users home directories as network shares on a central server to provide roaming profiles for the users. That is, the user will have the same environment regardless of the machine used for logging
      + through automount
      + as soon as user login's, the home is mapped from remote server to local server
      + whenever network is not availabe the home environment will not be available
    + if there is no home directory specified for the user, an error message will be displayed and the user will be placed on the root directory /
**** The login shell
  + The login shell
    + 
**** The useradd command
*** storage
*** periodic processes
*** backups
*** syslog and log files
*** tcp/ip networking
**** TCP/IP overview
     + tcp/ip: the internet language
       + protocol used for all major networking services like www and email systems
       + it is used to interconnect machines across small, medium and huge networks. it's also the protocol that powers high level internet services like HTTP, FTP, POP, SMTP etc
       + tcp/ip is adaptive architecture and not being owned by any company or person (non-proprietary)
     + How do packets find their way around the network ?
       + every network adapter has a Media Access Control number (MAC address). it's unique value supplied at manufacturing time. using MAC addresses to identify network devices is called Physical Addressing
       + on very small networks, adapter listen for all the traffic passing through to determine whether or not data is intended for their own MAC address. Devices are joined by a device called hub (rarely used now)
       + as networks get larger, a device is installed to ensure that packets get addressed only to their intended recipeints. it's called a switch
       + as networks get larger, physical addressing becomes less effective. networks are segmented using Logical Addressing
       + In logical addressing, each device is assigned a number called IP address. This number is unique across the subnet. Different subnets are connected through a device called a router
       + TCP/IP supports both types of addressing
     + what is a protocol ?
       + a set of common rules that controls communication between two or more devices on a specific medium (wire or radio)
       + a protocol uses the networking components and daemons on the operating system, the network hardware, and transmission medium to send or receive a message from a remote device
       + a network aware application uses the TCP/IP stack to communicate with other applications
       + the protocol defines the contents of each packet in a standard way that can be interpreted by the receiving device
     + TCP/IP skeleton
       + transmission control protocol/internet protocol (TCP/IP), a set of network protocols stacked over each other and designed to work with each other
         + application layer: 
**** the Link layer
**** classless inter domain routing (CIDR)
**** routing
*** netfilter and ip tables
*** dns: the domain name system
*** the network file system
*** sharing files with windows
*** email services
**** email services
     + why host your own e-mail services
       + gmail, yahoo, hotmail are targeted towards personal accounts
       + sometimes you can never store your important corporate email messages offsite, for this reason you have to learn how to host your own email server on your own infrastructure
     + a typical email system consists of
       + components involved in this operation
         + mail user agent (MUA) - your email client application (thunderbird, ms outlook or /bin/mail)
         + mail submission agent (MSA) - receives the mail message from the MUA and delivers it to the MTA (mail transport agent)
         + mail transport agent (MTA) - also called message transfer agent on mail relay. is reposible for delivering the message to the destination machine. it is also responsible for receiving the message on the recipient machine. a server that oeprates the MTA part of the main system is called mail exchange server. it is the machine that is designated the mx record in a dns server. postfix, sendmail and microsoft exhange server are examples
         + mail delivery agent - is responsible for delivering the message to the client's mailbox, it's incorporated inside mail systems like postfix and sendmail
         + access agent (AA) - optional component that may be used to connect MUA to the message store
     + message user agent (MUA)
       + also called email client, it's s/w that reads and creates mail messages
       + earlier days email message contains only plain text, later MIME (multipurpose internet mail extension) was introduced to enable rich text format as well as attaching images and files
       + mua's include modern email clients like thunderbird and microsoft outlook and also the plain old text based clients like /bin/mail
       + native linux mail client is indispensable when running cron jobs: as cron sends an email to the user with the output of cron job commands
     + mail submission agents (MSA)
       + ealier days, msa was part of of mta (mail transport agent) but they were later split into two separate components
       + it listens on port 587 in contrast to mta which by default listens on port 25, because both mta and msa use the same protocol, they are transparent to the user agent, specially if the msa was configured to listen on port 25
       + one of the important tasks handled by msa is spam filtering
       + it does lots of processing on mail messages before delivering to mta
     + mail transport agent (mta)
       + used for sending and receiving mail messages
       + it accepts messages either from user agent or submission agent
       + uses simple mail transfer protocol (SMTP)
       + mta understands the recipient address as rewrites it - if necessary - to be understood by the delivery agent
       + if the message is not intended for the current domain, MTQ acts as a "relay server" and forwards the message accordingly
       + exampls of mta's are postfix, sendmail and exim
     + mail delivery agent (MDA) and message stores
       + also called local delivery agent (LDA), it receives mail messages from MTA and delivers them to the local users mailboxes, sometimes LDA is part of MTA
       + message store is the final component in the mail system, it is where the mail message gets stored
       + messages may be stored in 'mbox' format, where messages are stored in one single file (e.g. /var/mail/root) and they are separated by a special line of text
         + % cd /var/mail
         + % ls -ltr; # users and mails
         + % cat user1; # file contains all the messages of user1
       + they can also be stored in 'maildir' format, where each message is stored in a separate file
     + access agents (AA): POP and IMAP
       + those are used to access the mail system and download the messages for reading on the client device (workstation, laptop, smartphone ... etc)
       + IMAP (internet message access protocol) - downloads messages one by one instead of bulk downloads, it also gives the user the option to view the header and type of attachments. the user then can opt to download the attachment
       + POP (Post Office Protocol) - downloads the whole mailbox to the user's local device. it is not suited for a slow network
       + most mail clients support both POP and IMAP
     + the mail message
       + mail message consists of following components
         + the envelope - it contains the 'From' and 'To' fields. these are not part of the message itself
         + the headers - these are a set property/value pairs containing a variety of information about the message like the time of sending and the transport agents that processed it
           + headers are very important in troubleshotting as they reveal information about any errors or problems encountered during the message delivery journey
         + the body - either in plain text or in MIME format
**** lab: configuring a mail server using postfix
     + lab: configuring a mail server using postfix
       + 'yum -y install postfix' - install postfix package using package manager
       + open the main configuration file '/etc/postfix/main.cf' file to configure your mail server
       + the server by default listens for traffic on the loopback device. we need to change this to enable it to serve our netwokr
         + 'inet_interfaces = all'
       + configure the outgoing domain to be 'linuxadmin.dev', otherwise the system will use the hostname instead of the domain
         + 'mydomain = linuxadmin.dev'
         + 'myorigin = $mydomain'
       + specify the domain name for which postfix will handle its mail. by default postfix only handles email directed to the local machine
         + 'mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain'
       + set the network subnet(s) on which postfix will act as a relay server. this option prevents spammers from making use of your server to send harmful messages
         + 'mynetworks_style = subnet
       + clients from outside your subnet must be authorized to use the server to send emails to your domain and - optionally - to other domains that you choose to be their mail relay
         + 'relay_domains = $mydestination'
       + when your clients want to send emails to recipients in other domains, the server can either send the message directory to the MX machine of the destination domain, or ask another server (relay host) to do this host. A relay host may be your ISP
         + 'relayhost = $mydomain'
       + you can use user-friendly names instead of usernames by editing the '/etc/aliases' file. you have to run 'newaliases' command after you make any edits
       + test your work my downloading a text-based mail client called mutt
         'yum -y install mutt'
       + send a test email message to one of the system users and use the '/var/log/maillog' message to troubleshoot any problems
       + % vim /var/named/linuxadmin.dev.fwd.zone; # already created dns in previous sections'
       + add 'linuxadmin.dev.  IN  MX  10  mail.linuxadmin.dev.'
       + add 'mail  IN  A  <ip>'
       + % vim /var/named/linuxadmin.dev.rev.zone
       + add '252  IN  PTR  mail.linuxadmin.dev.'
       + % vim /etc/postfix/main.cf
       + add 'inet_interfaces = all'
       + add 'mydomain = linuxadmin.dev'
       + add 'myorigin = $mydomain'
       + add 'mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain'
       + add 'mynetworks = subnet'
       + add 'relay_domain = $mydestination'
       + add 'relayhost = $mydomain'
       + % service postfix reload
       + % tail /var/log/maillog; # check for any errors
       + % mutt; # text based mail client, useful for cronjobs
       + 'M' To:root@linuxadmin.dev
         Subject: Linux Admin Course
         This is the email section of course
         :wq
         'Y'; # message sent
       + % tail /var/log/maillog; # check for any error during mail sending
       + % mutt; # check for message
       + % vim /etc/aliases; # alias for each user
       + add 'root:  user1'
       + % newaliases; # reloads aliases file
       + % su - user1
       + % mutt
       + send new message
       + mail is delivered to user1 as we specified for the mail to be delivered to user1
*** network management and debugging
*** security
*** ssh tips and tricks
*** web hosting
*** performance analysis


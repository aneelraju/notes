* linux
** udemy - fundamentals of unix and linux system administration - eduonix
*** where to start
**** linux unix administration
     + an administrator is not expected to be a "walking book". linux has a huge number of commands, with a lot of different options and arguments. effectively using the man pages, and figuring out how a specific command works is an indispensable skill
     + https://en.wikipedia.org/wiki/List_of_Linux_distributions - Linux Distributions
     + most common linux - redhat (centos, oracle linux, fedora), debian (ubuntu), suse
**** getting help on linux
     + MAN pages - manual pages
       + 'man command' - e.g.
       + several sections 
         + commands and applications (man 1)
           + 'man passwd' - modify a user's password - PASSWD(1)
           + 'man 5 smb.conf' - samba configuration file
           + 'man 1 smblclient' - various options of smbclient command 
         + system calls (man 2)
         + library calls (man 3)
         + drivers (man 4)
         + files (man 5)
           + 'ls -l /etc/passwd' - passwd of users and other info
             + 'man 5 passwd' - this give section 5 passwd man page
         + and more
       + you can use (similar to) 'more' or 'less' command shortcuts for navigation
         + '<space>' - moving forward
         + 'ctrl+b' - moving backword
         + 'ctrl+f' - moving forward
         + ':q' - quit
         + '/<keyword>' - search keyword
       + 'man -k keyword' - search for (inside description or title) a specific man page 
         + 'man -k update' 
         + 'man -k printf'
       + 'man -a keyword' - search in the title only and display multiple man pages
         + 'man -a printf' - gives first man page occurance then next and next
**** advance man command
     + 'man -af keyword' - to search only in the title
       + 'man -af passwd'
     + '<command> -h' or '<command>' or '<command> --help' - provide help, sometimes useful as man's are lenghty
       + 'find' - gives option, check 'man find'
     + 'whatis <command>' - to know whether a command is installed on not or want to know it's path
     + to update man page
       + redhat: 'makewhatis'
       + ubuntu, suse: 'mandb'
     + 'which <command>'  - find the path of a command
       + 'java' - gives java command options
       + 'which java' - java path
     + 'history' - list the commands that you have issued
       + 'export HISTTIMEFORAMT="%d/%m/%y %T "' - set env variable to show time stamp
     + 'du:' - find amount of space taken by a file or directory
       + 'du -h -max-depth=1 *' - find the file and directory sizes in the current location in a human readable format
         + 'du -h -d=1 *' - in mac
     + 'echo > file' - empty a file without deleting it
     + other online documentation
       + linux.com
       + kernel.org - related to kernel, sourcecode is available
       + serverfault.com - important one, q&a site
*** package management
**** introduction to package management
     + traditional way
       + download .tar.gz files
       + './configure' and 'make install'
       + doesn't handle dependencies, may overwrite customized configuration files, hard to uninstall
       + centos:
         + % ls -ltr; # download htop-1.0.3.tar.gz
         + % tar -xvf htop-1.0.3.tar.gz; # famous package to monitor cpu and memory performance
         + % ./configure; # check for the system, we don't have gcc compiler
         + % ls -l /etc/ntp.conf; # network time server to sync with your own time; this file can get overwritten during installation and older config can be deleted
     + packages
       + preserves configuration files
         + e.g. if new version of httpd is installed, the httpd.conf is created as httpd.conf.rpmnew
       + dependencies are considered
       + pre and post install scripts can be deployed with the application
       + multiple packages can be wrapped in same package
         + https://www.libreoffice.org - famous office suite for linux, it's a multiple package
       + can easily uninstall or exclude their dependencies
       + linux package types
         + rpm - red hat package (.rpm), used by red hat, suse; to install use 'rpm' command
           + % rpm; # gives options
           + % rpm -i; # install command
           + % rpm -U; # update command
         + debian - ubuntu and other debian systems (.deb); to install use 'dpkg' command
         + both of these commands don't handle dependencies, cannot be used to search for packages and do not offer metadata about package
           + centos:
             + % ls -l vim-enhanced-7.4.629-5.el16.x86_64.rpm; # download vim enhanced package
             + % rpm -i vim-enhanced-7.4.629-5.el16.x86_64.rpm; # rpm install, it fails because of dependencies
         + yum (yellowdog updater modified), apt (advanced package tool) and zypper are introduced to overcome shortcoming
**** installing from RPM
     + redhat rpm:
       + -i : install; -U : upgrade; -e : erase; -q : query (used with other options)
       + % rpm -qa; # displays all packages installed on the system
       + % rpm -qa | grep <package>; # to determine whether package is installed or not
     + debian's dpkg:
       + --install; --remove; -l - to display installed packages
       + % dpkg -l | grep <package>; # to determine whether or not a package is installed
     + package managers
       + it needs repository, a repository is like a container containing packages, with their respective metadata
       + each vendor offers it's own repository (repo). packages are offered for download in HTTP or FTP
       + 'yum install' (red hat)/ 'apt-get install' (ubuntu)
       + redhat yum:         
         + % yum install lsof; # centos: package gives vast info about system, processes, network sockets, users using directories etc
         + '/etc/yum.repo.d/public-yum-o16.repo' - yum repo
       + ubuntu apt-get
         + % apt-get update; # update the local cache data sources (repositories) to reflect the latest changes, do update before any installation
           + '/etc/apt/sources.list' - file contains the source URLs for the packages, you needn't change this file unless you want to use your own apt repository
             + file contains types of packages those fully supported by ubuntu (main), unsupported open source packages (universe) and paid unsupported packages (multiverse)
**** making a local apt-get repo
     + used if you are managing a large number of ubuntu machines, and you need all of them share one local repo to save bandwidth
       + % apt-get install apt-mirror ; # install apt-mirror
     + /etc/apt/mirror.list - configuration file
       + % apt-mirror ; # starts mirroring process, first time takes lot of time. subsequent runs will consume much less time and can be automated by using cron jobs
     + /var/spool/apt-mirror - directory where packages are download, need atleast 50GB (path can be change in configuration file)
       + % ls -l /var/spool/apt-mirror/skel/archive.ubuntu.com/ubuntu
     + '/var/spool/apt-mirror/var/clean.sh' - delete obsolete packages
     + make it web reachable via HTTP or FTP (like symbolic link from your web directory to the packages directory)
       + % cd /var/www/html/
       + % ln -s /var/spool/apt-mirror ubuntu
       + % ls -ltr
     + all clients have to change their sources.list files to point to the local repo
     + you can automate system upgrades by using cron jobs, run 'apt-get update' before upgrade to ensure that you have the latest data
     + 'apt-get upgrade' or 'apt-get dist-upgrade' - upgrade command, later may delete packages that are not compatible so use it with care
     + '--yes' - use it for full automation, this will confirm all dialogs, use it with care
     + some updates require system reboot to be reflected like kernel upgrades
     + '--download-only' - to download the packages only and install them later after reviewing it
       + /var/cache/apt - packages directory
       + 'apt-get install /var/cache/apt/<package>' - to install/update specific package
       + 'apt-get autoclean' - to remove files that are no longer used
**** making local yum repo
     + /etc/yum.conf - configuration files
       + by adding 'proxy=http://proxy:8080' to /etc/yum.conf you can instruct yum to download and install through proxy
     + /etc/yum.conf.d - repositories themselves, you can add repo info to the same config file, but this is a bad practice
     + 'yum update' - to make system-wide upgrade, 'yum upgrade' does the same task, different meaning to 'apt-get update'
     + 'yum install' - install packages
     + 'yum update' - upgrade
     + 'yum remove' - uninstall packages
     + '-y' - auto-confirmation, discretion is advised
     + 'yum install http*' - will install httpd, asterisk before and after partial package name works
     + 'file:///' url points to the mounted filesystem of the DVD (not the live CD)
       + if needed, this can be further extended to serve other systems on the same network form the same DVD
       + use symbolic link in the web directory that points to the mounted DVD filesystem and update the appropriate client repo configuration to point to it
     + % ls -l /dev/sr0' - cdrom location (redhat dvd)
     + % mount /dev/sr0 /mnt/ - mount cdrom
     + % cd /mnt/
     + % ls -l
     + % cd packages; # lot of rpm packages
     + % cd /etc/yum.repos.d; # update repo
     + % vi media.repo; # new file
       + add '[DVD]
              name="DVD repository"
              baseurl=file:///mnt
              enabled=1
              gpgcheck=0
             '
     + % yum repolist; # check repo list
     + % yum --disablerepo=public_* install httpd; # temporarily disable public repo, install from DVD
     + % cd /var/www/html; # defaul web directory of httpd
     + % ln -s /mnt/ RedHatRepo; # make symbolic link
     + % service httpd start; # start httpd service
     + % iptables -vnL; # ensure firewall didn't disable http traffic
     + % iptables -F; # temporarily disable firewall
       + in browser https://<ip>/RedHatRepo - packages are visible
       + all m/c in network can use http service to install packages
     + local mirror
       + done using 'reposync' command, it's part of 'yum-utils' package
       + % yum -y yum-utils
       + % mkdir /repository; # should have sufficient space 50GB
       + % cd /repository
       + % reposync -r public_o16_latest -p /repository/; # to get repo rame vi /etc/yum.repos.d/public-yum-o16.repo, downloads packages locally
       + % cd /repository/public_o16_latest
       + % ls -l; # list of packages
       + % yum -y install createrepo; # install createrepo
       + % createrepo .; # create repo on directory; creates metadata 'repodata' directory
       + make a symbolic link from your web directory to the packages directory to make it web reachable
       + make appropriate changes to the clients repo configuration files to point to the new mirrored repo
**** tips and tricks
     + yum plugins
       + add extra features to yum and they are powerful
       + 'yum-fastestmirror' - makes yum auto choose the fastest connection to mirro
         + /var/cache/yum/timeshosts.txt - data is stored, you can force yum to recheck the fastest connection by removing this file
         + % yum -y install yum-fastestmirror
         + % yum update
       + 'yum-security' - enables yum to use the '--security' command line argument which makes yum ignores any packages other than the security related
         + % yum -y install yum-security
         + % yum --security update; only security related update
       + 'yum-presto' - decreases the download size when updating a package by downloading only the change between the installed and the new one (delta rpms)
         + % yum -y install yum-presto
         + % yum update
       + 'yum search <package>' - to search package
         + % yum search ssh; # list of packages that contains
       + 'yum whatprovides *command*' - some commands are part of packages that have different names, to search for them
         + % yum -y install scp; # scp not found because scp is not a package
         + % yum whatprovides *scp*; # look for openssh-client-*, this is the package that needs to be installed
         + % yum -y install openssh-clients
       + 'yum info <package>' - info about package
         + % yum info openssh-clients; # info about openssh
       + 'yum groupinstall group' - to install groups of packages like a desktop environment
         + % yum -y groupinstall "Desktop" "Desktop Platform" "X Window System" "Fonts"; # install group of packages
       + 'yum clean all' - to recreate cache (useful if you are behind proxy)
         + % yum clean all
         + % yum update; # it's re-downloading packages
*** shell scripting guide
**** introduction to shell scripting
     + saves time and effort. can be scheduled if use in Cron job
     + sh (bourne shell) is dominant one before bash (bourne again shell). other shells include ksh (korn shell) and csh (c-shell). default shell on centos and ubuntu is bash
     + csh used to make c programmers feel at home
     + % ksh; # starts ksh
     + if the task at hand is much more complex than to be solved by a bunch of shell commands, you can opt to use a fully fledged language like python or perl
     + if you are an emacs user, you can use following shortcuts to communicate with the shell
       + ctrl-e - jump to the end of the current line
       + ctrl-a - move to the line beginning
       + ctrl-p - brings the last used command
       + ctrl-n - brings the next used command
       + ctrl-r - lets you search for commands in history of the last used ones
     + 'set -o vi' - to enter vi mode at cli
     + 'set -o emacs' - to enter emacs mode at cli
     + process file descriptors (fd)
       + a process communicates with the system using channels called file descriptors (fd)
       + atleast 3 channels are available to a given process
         + stdin - standard input, for which the process accepts input, it is numbered as 0
         + stdout - standard output, to which the process directs any output produced, it is numbered as 1
         + stderr - standard error, to which any error messages are directed, it is numbered as 2
       + % ps -ef; # processes running in the system
       + % ls -l /proc/45163/fd; # to examine the current fd's used by a process by listing the files under the virtual directory /proc, where 45163 is process number
         + /proc - not real directory, it provides you important info about running processes
       + redirect standard output and standard error to a file using '>' and '>>'
         + % useradd user1; # add user1
         + % su - user1; # su user1
         + % find / -name core > output.txt 2>error.txt; # output to output.txt and error to error.txt
       + direct both error and output to the same destination using '&>'
         + % find / -name core &> output.txt; # both output and error to output.txt
       + instruct the process to take it's standard input from a file using '<'
         + % mail -s "output" root < output.txt; # write mail with output.txt as input
         + % mail; # check mail
       + inject the STDOUT of a command to the STDIN of another using the '|' (pipe)
         + % ls -l | grep install; # '|' is pipe
**** using variables
     + 'USER=joe' - example to assign a variable USER with value jeo, no space between '=' sign
       + % newvar="This variable contains text"
     + '$USER' - to call a variable or ${USER}, useful when using variable with literal text like ${ORACLE_HOME}/oraInventory
     + ''$HOME'' - will print $HOME
     + '"$HOME"' - will print home directory path of current user
     + you can add your environment variables in ~/.bash_profile or ~/.profile
       + % env; # lists env
     + 'cut' command
       + take STDIN, preform some processing on it before returning result as STDOUT
       + used to display parts of the input text, often used with delimited files like cs, and /etc/passwd
       + default delimiter is TAB character, but this can be changed using the -d command line argument
       + % cut -d , -f 1,3 < sample.csv; # to select the fields you want to display, use -f option followed by a comma separated list of numbers
       + % echo "This,Is,Cut,Example" | cut -d , -f 1,3; # prints This,Cut
**** the sort command
     + 'sort' command
       + sorts the lines of text give to it, type of sort: numerical or dictionary based
       + % sort -t , -k1,1 -n < sample.csv; # wll sort the lines of sample.csv in an integer based way, regarding the comma as a column delimiter and the key column is 1
         + '-d' - sort by dictionary
         + the key column can be more than one so we must specify that it will take only one column by inserting a comma and providing an end value k1,1
         + '-r' - to reverse order
         + '-u' - to print unique values only
         + '-b' - to ignore leading spaces
       + sort is usually combined with another filter command like 'cut' or 'uniq'
     + 'uniq' command
       + it returns the unique lines of a given text input
       + '-d' - to print duplicated lines
       + '-c' - to count the number of duplicated/non-duplicated lines
         + % uniq -u < sample.csv; # doesn't change anything, it has be sorted first
       + to use 'uniq' lines must be sorted first
         + % sort -t , -k1,1 sample.csv | uniq -u; # shows unique values
         + % sort -t , -k1,1 sample.csv | uniq -d; # shows duplicated values
         + % sort -t , -k1,1 sample.csv | uniq -dc; # shows duplicated values and no. of occurance
         + % sort -t , -k1,1 sample.csv | uniq -c; # will print the number of times a line has been entered in the sample .csv file
     + 'wc' command
       + word count to count words, lines and characters
         + % wc sample.csv # gives all in words(space as delimiter) lines and characters
       + '-l' - for lines
         + % wc -l sample.csv # gives lines
       + '-w' - for words
         + % wc -w sample.csv # gives words
       + '-c' - for characters
         + % wc -c sample.csv # gives characters
       + to start and stop service
         + % service httpd start; # starts httpd service
         + % service httpd stop; # stops httpd service
     + 'tee' command
       + to view the standard output of command while it's being written to a file
       + it's like a monitoring command
         + % find / -name *.log | tee output.txt; # will print the output to the screen and to output.txt file at same time
     + 'head' command
       + prints the first 10 lines of a file
       + '--lines=n' - will print only the specified number of lines, can be used as head -n
         + % head -5 sample.csv; # prints first 5 lines
       + '--lines=-n' - will print all lines in the file except the last n lines
     + 'tail' command
       + prints last 10 lines of a file
       + '--lines=n' - prints the last n number of lines in a file, can be used as tail -n
         + % tail -5 sample.csv; # prints last 5 lines
       + '--lines=+n' - prints all lines in a file starting with line number n
       + '-f' - will keep the file open, displaing any new lines added to it. This is typically used with log files
         + % logger "Hello"; # logger logs message to a main file in the server
         + % logger "This is a log message"
         + % tail -f /var/log/messages; # displays logs
       + '--pid=PID' - makes the command exit after the process which is writing to the file you're tailing exits.
         + useful so that you know if the process has exited or it's just not writing any output at the current moment
     + 'grep' command
       + searches for text in it's standard input and outputs
       + you can use regular expressions in pattern matching
       + '-c' - get the number of matches instead of printing them
         + % ps -ef | grep -c ssh
       + '-i' - ignore case when searching
       + '-v' text - matches if the text is not present
         + % ps -ef | grep ssh | grep -v grep; # removes grep ps from output
       + '-R' - perform a recursive search in current directory and all subdirectories
         + % grep -l root .; # it will output files that contain the text, searches in current directory
         + % grep -Rl root .; # it will search sub directories
**** basics of bash script
     + % bash script.sh; # to run bash script
     + '#' - comment
     + ';' - mutiples commands are separated in the same line
     + add '#!/bin/bash' as first line to make script self executable
     + 'echo'  - to print text to screen
       + '-e' - make it work like printf (interpret special characters like \t and \n)
       + '-n' - do not add newline character to the end of the line
       + % echo "Hello\n"
       + % echo -e "Hello\n"
       + % echo -n "Please enter your name: " # doesn't add new line
     + 'printf' - also prints text, allows to output special characters like tabs (\t) and add newline character (\n)
       + % printf "Hello\n"
     + 'read' - accept input from user followed by a variable
       + % echo -n "Please enter your name: "
       + % read user_input; # input to variable user_input
       + % echo "Hello " $user_input
     + arguments
       + arguments are interpreted by bash as $1, $2, $3 and so on
       + '$0' - holds the name of the script file
       + '$#' - contains the number of arguments passed to the script
       + '$*' - contains all the arguments passed at one
       + command line argument variables with special ones can be used to test whether or not the user has supplied the correct input if at all
         + and print a friendly usage message accordingly
         + sample usage code
           '#!/bin/bash
           if [ [ $# -eq 0 ] ]; then
             echo "Usage: " $0 "your name"
             exit 1 # failed exit
           fi
           echo "Hello " $1
           exit 0 # success exit' 
**** shell functions
     + shell functions
       + 'function function_name { code }' - syntax
       + sample code
         '#!/bin/bash
         function usage {
           echo "Usage: " $0 "your name"
         }
         if [ [ $# -eq 0 ] ]; then
           usage
           exit 1
         fi
         echo "Hello " $1
         exit 0'
       + usage is not restricted to shell scripting, you can also use them as an alias to your shell commands
         + you can add a function to your .bash_profile and use it as a command
         + 'function grepv {
            grep -v grep
           }'; # in ./bash_profile
         + % ps -ef | grepv | wc -l; # grepv is shell function
         + % 'alias ls="ls -ltr"'; # this is fine, but function can have more complex code
     + variable visibility
       + variables are global by default, but a function can make variable accessiblity limited to their own scope by using keyword 'local'
         + the variable retains its original value as soon as code execution leaves the function where the variable was created as local
     + decision making
       + sample code
         'id=`id -u`
          if [ $id -eq 0 ]; then # spaces needed before and after the square brackes
            echo "This script cannot be run as root"
          else # you can use 'elif' for else if condition
            echo "Welcome to our script"
          fi'
     + test command
       + '[ ]' in if condition is shortcut to /bin/test command
       + 'man test' - check for full list 
       + equal to 
         + '=' - string like '$user = 'Sam''
         + '-eq' - number like '$id -eq 1'
       + note equal to
         + '!=' - string like '$user != 'John''
         + '-ne' - number like '$id -ne 5000'
       + greater than
         + '-gt' - number like '$count -gt 0'
       + less than
         + '-lt' - number like '$limit -lt 100'
       + greater than or equal
         + '-gte' - number like '$count -gte 0'
       + less than or equal
         + '-lte' - number like '$limit -lte 100
       + file attributes
         + '-d directory' - directory exists
         + '-e file' - file exists
         + '-f file' - file exists and is a regular file (not a block device for example)
         + '-r file' - file is readable
         + '-s file' - file is not empty
         + '-w file' - file is writable
**** looping
     + 'for..in' - loop to iterate over a group of values and perform some commands on each one
     + sample code
       'for f in *.log; do # can accept a group of files by using globing through asterisk * or a question mark ?
          echo gzip $f # always good idea to add echo to print operations on screen
        done'
     + sample code
       'for i in user1 user2 user3; do
          echo $i
        done'
     + classic for loop is available in bash
       + sampel code
         'for (( i=0; i<$count; i++)); do # i is not preceded by a $ in the loop definition
            echo $i
          done'
     + while loop
       + continue to iterate as long as a specific condition is met, often used in reading strings such as user input or a text file
       + syntax
         'while [ [ condition ] ]; do
            code
          done'
       + sample code
         '#!/bin/bash
         input=""
         while [ [ $input != 'Y' ] ] do
           echo -n "Please enter Y to continue"
           read input
         done'
       + syntax for infinite loops, this is typically done in daemons that work in the background, listening fo ran event and acting accordingly
         'while true; do
            code
            sleep n seconds # needed so that you don't exhaust your machine resources
          done'
       + sample code
         '#!/bin/bash
          while true; do # 'true' is to continue infinitely
            echo 'date' >> timestamps.text
            sleep 1
          done'
       + ./<shellscript> & # '&' is to run the script in background
       + 'jobs' - lists running job
       + 'fg %1' - run job 1 in foreground; 'ctrl+z' to stop foreground
       + 'bg %1' - run job 1 in background
       + % tail -f timestamps.text; # file is updating
**** perl
     + fully fledged programming language that is must more powerful than bash
     + perl or python are designed for shell scripting
     + % yum install perl; # centos perl install
     + % apt-get install perl; # ubuntu perl install
     + sample code
       '#!/usr/bin/perl
        # this is comment
        $myvar = "Eduonix";
        print "$myvar\n";'
**** perl arrays
     + sample code
       '#!/usr/bin/perl
        @users = ("user1","user2","user3"); # array assignment
        print "$users[1]\n"; # scalar print
        $count = $#users;
        print "This array has $count number of users";'
     + sample code
       '#!/usr/bin/perl
        @users = ("user1","user2","user3", "user4"); # array assignment
        @admins = @users[1,2];
        print "The admins are $admins[0] and $admins[1]\n";'
     + sample code
       '#!/usr/bin/perl
        %user = ("username" => "johndoes", "password" => "changeme", "name" => "John Doe"); # hash assignment
        print $user{"name"}."\n"; # '.' is concatenation operation
        @slice = @user{"username", "password"}; # slice operation
        print "Username is".$slice[0]." and password is ".$slice[1]."\n";
**** perl script arguments
     + sample code
       '#!/usr/bin/perl
        print "What is your name? ";
        $input = <STDIN>; # input from user or other process via pipe '|'
        chomp ($input); # chop trailing spaces
        print "Hello ".$input."\n";'
     + sample code 
       + % ./perlinput username password
         '#!/usr/bin/perl
          $count = $#ARGV + 1;
          print $ARGV[0]."\n"; # print arguments
          if ($#ARGV == -1) {
            print "Usage $0 username\n";
          }
          if ($count < 2) {
            print "Usage $0 username password\n";
          }'
     + 'if' syntax
       + 'if (condition) {
            code if condition is true
          }
          elseif (condition) {
            code if above condition is false
          }
          else {
            code if all conditions are false
          }'
     + perl operators
       + equal to - string - 'eq' - $user eq 'Sam'
       + equal to - number - '==' - $id == 1
       + not equal to - string - 'ne' - $user ne 'John'
       + not equal to - number - '!=' - $id != 5000
       + greater than - number - 'gt' - $count gt 0
       + less than - number - 'lt' - $limit lt 100
       + greater than or equal - number - gte - $count gte 0
       + less than or equal - number - lte - $limit lte 100
     + perl loops
       + for syntax
         'for ($i=0;$i<10;$++) {
          }'
       + foreach loop syntax, works best with arrays
         'foreach $var($variables) {
            $var holds the current array item value
          }'
       + while loop syntax
         'while (condition) {
            code
          }'
       + infinite loop syntx
         'while (true) {
            code
            sleep n seconds
          }'         
     + sample code
       + % ./pse -ef | ./perforeach.pl ssh # this is like grep function
         '#!/usr/bin/perl
          @input = <STDIN>;
          foreach $line(@input) {
            if (index($line,ARGV[0]") != -1 && index($line,"perl") == -1) { # index is string search function
              print $line;
            }
          }'
**** python scripting - part A
     + python is generally more readalbe than perl, language is maintained in two streams: 2 (latest 2.7) and 3 (latest 3.5). Both are considerably different
     + it has it's own interactive shell, which is useful to test your commands before putting them in a script
     + python is said to have batteries included, means that it has got a lot of built-in functionality that make it independently robust enough to handle most tasks
     + it uses modules to encapsulate different types of tasks like 'os' module, 'time' module
     + 'sys' and 'os' modules are working with shell scripting and operating system in general
     + sample code
       + % python -v # python version
       + % python # interactive shell
       + p% print "username"
       + p% ctrl+d # exit python
     + sample code
       + % ./mypython.py username
         '#!/usr/bin/python
          print ("Please enter your name ")
          input = raw_input()
          print ("Hello " +  input)
         '
     + if condition syntax
       'if condition:
          code if true
        elsif condition:
          code if previous condition is false and this one is true
        else:
          code if all conditions are false
     + sample code
       + ./mypython.py username
         '#!/usr/bin/python
          import sys # importing sys module
          if (len(sys.argv) == 1): # len is length python function
            print "Usage " + sys.argv[0] + " username"
         '
**** python scripting - part B
     + lists are like arrays, a group of values saved assigned to one variable
       + 'listname = [val1, val2, val3]
     + tuples are the same as lists, but they cannot be modified
       + 'tuplename = (val1,val2,val3)'
     + dictionaries can be thought as associative arrays, they contain key value pairs
       + 'mydict = {key1:value1,key2:value2,key3:value3}'
     + python loops
       + for loop syntax
         'for item in item_sequence: # item_sequence could be any variable that can be iterated over, a list or a tuple
            code'
         + sample code
           + % ./mypython.py username password
             '#!/usr/bin/python
              import sys
              i = 1
              for c in sys.argv:
                print ("Command argument " + str(i) + " is "+ c)
                i = i + 1
             '
       + while loop syntax
         'while (condition):
           code'
       + infinite loop syntax
         'while (True):
            code
            time.sleep(n seconds) # import time module'
     + you can make python execute shell commands by using the subprocess module, provides call function which will execute the command you pass to it as parameter
       + sample code
         + % ./mypython.py
           '#!/usr/bin/python
            import sys
            import subprocess
            output = subprocess.call(["ls","-l"]); # subprocess takes inputs as lists
            print output
           '
     + shell scripting is a robust way to automate repetitive tasks
*** booting and shutting down
**** starting up and shutting down machines
     + bootstrap
       + bootstrapping is the process by which the system initializes until it is available to users
       + kernel is loaded into memory and starts execution, any startup script is executed 
       + bootstrapping process fails sometimes due to error in one of configuration (like /etc/fstab), damaged hardware, filesystem corruption
         + /etc/fstab - file responsible to mount files during startup
       + bootstrap process
         + code (firmware) saved in the ROM gets executed, it determines where and how to start the system's kernel
         + when the kernel loads, it checks for the system's hardware and starts the first and most important process, the init. The init process has always PID of 1 ('ps -ef')
         + filesystems are checked for any corruption, the system attempts to fix any recoverable errors it may find
         + after filesystems are checked and mounted, the system's startup scripts get executed by the init process
         + finally the login prompt/gui interface appears and the system becomes ready for users
     + kernel loading
       + is a program that gets loaded into the system's memory, it's loaded by a program called Boot Loader that executed from ROM
       + while loading, the kernel probes the attached hardware, and assigns an amount of RAM for itself, this part of memory will not be available to the user side
       + on linux systems, kernel can be found under '/boot'  (e.g. /boot/vmlinuz-3.8.13-118.e16uek.x86_64)
       + when kernel is loaded, it creates number of startup processes, most important one is 'init', having pid 1
       + other processes are created after that can be identified by having square brackets around them (like [kworker/0:1], / represents the processor number on which the process is running), these can't be treated as normal processes and should never kill it
         + 'ps -ef | grep "\[.*\]"'
**** startup daemons
     + startup daemons
       + after kernel is loaded, the startup daemons start to get executed by the init process, they are normal shell scripts that loads important system services like sshd, ntpd, httpd, dns, nfs ... etc
     + stage 1 - the bios
       + on proprietary systems (aix, hp-ux and sparc), the boot code is not stored in bios, it's stored in a much more powerful firmware, which has enough info about the attached hardware and can talk to the network on a simple level
       + on pc's the bios is responsible for executing the boot code, it's much simpler than proprietary m/c firmware
         + several types of bios, one for m/c another for video card and for scsi
       + bios config lets you choose the media from which you want the system to start and order by which it'll search for alternate media (or network) if first one fails
       + the boot media has it's first 512bytes checked to determine which partition contains the boot loader, the boot loader is responsible for loading the kernel
     + stage 2 - grub
       + grub is Grand Unified Boot Loader, it is the default boot loader in linux and unix systems running on intel processors
       + it reads configuration options from '/boot/grub/menu.lst' (on ubuntu and suse) and '/boot/grub/grub.conf' on red hat
       + configuration file options are
         + 'default=number' - which os/kernel to boot the system to. the list starts at 0. when new kernel is installed like through system upgrades, the old ones stay available for booting in the menu, so that you can choose to boot from them if the new one breaks the system
         + 'timeout=number' - sets the number of seconds the system would wait for a keyboard interruption before it loads the configured options
         + 'root (hd0,0)' - where to find the partition from which to load the system. the first disk and the first partition on the mc are defined as 0 and 0 respectivelly
         + 'kernel' loads the kernel from the specified path
       + grub command line interface
         + in can be invoked by typing 'c' in the GRUB boot screen
         + it provides a basic command line interface that has some useful grub commands, you can have a list of possible commands by typing <TAB> twice
         + one of the most useful cases of using GRUB cli is to boot OS that is not configured in grub.conf file, assuming OS is installed on the first partition of the second disk on the m/c this can be done as
           + 'root (hd1,0)'
           + 'kernel /vmlinuz-[select the kernel image you want] root=/dev/sdb2 [root specifies where the root(/) filesystem is located. sdb2 is disk 2, partition 2]'
           + 'boot'
           + example
             + type 'c' on grub boot screen
             + g% <TAB><TAB> # lists commands
             + g% root (hd0,0) # harddisk 1 and partition 1
             + g% chainloader +1 # to load bootloader on 1 sector of 1 disk
             + g% rootnoverify # prevent to mount file system
             + g% boot # boot command
         + other useful commands include 'find', it will search the system for regular files only (no directories)
         + on failing system you can find, for e.g. which partition the kernel is installed (vmlinuz), or where the root partition is ('/sbin/init')
**** booting a second OS
     + booting a second OS
       + with grub, you have option to install more than one os on the same m/c and select which one to use on startup
       + if second os you wnat is microsoft windows, it's wise to install it before linux, because window deletes grub after installation
       + some changes have to be made to grub to enable the system to boot into windows
         + 'rootnoverify(hd0,0)' - this forces grub not to try to mount the root partition
         + 'chainloader +1' - make grub load the boot loader from the first sector of the selected disk (disk 1 partition)
     + kernel command switches
       + you can interrupt grub loading, while in the timeout period, by pressing any key. you can then select the kernel you wish to boot from, and press 'a' to start adding command switches
       + '1' or 'single' - to enter single user mode
       + 'n' - the run level to where you want the system to boot
       + 'init=/bin/bash' - will let the kernel load '/bin/bash' instead of '/sbin/init' process. both of these options will allow you to access system as root without password. it will run only bash instead of init
       + 'root=/dev/sdxx' - lets the system boot to a different root partition e.g. 'root=/dev/sdb1'
       + 'ro' - boots the system in read only mode, strongly recommened when you want to perform 'fsck' on the disks before booting, 'fsck' should never be done on a read/write system, fsck is file system check
       + 'debug' - prints a more verbose output of the kernel loading status, useful when you want to troubleshoot a booting issue
       + 'selinux 0 or 1' - disables/enables selinux module, selinux is security module that is installed in linux by default
       + after selecting kernel on grub screen type 'a'
         + k% 1 # login's as single user
         + k% passwd # reset passwd, can be used when you forgot root passwd
         + k% init=/bin/bash # give bash prompt
         + k% passwd # to change root passwd
     + single user mode
       + used to give the administrator the most basic functionality of a systme, when it fails to boot, multiple logins are disabled only administrator (root) can login
       + this login done physically on the machine and not through the network because networking is disabled in this mode
       + an administrator can choose to enter single user mode by editing the GRUB boot arguments, by using the shutdown command or by using the 'telinit' command
       + you are allowed, in this mode, to open a shell as root without being prompted for a password. this is one way to reset the root password if lost or forgotten
     + startup scripts
       + these scripts are run by the init process, they are normal scripts that do some "housekeeping" to the system like cleaning '/tmp' files, they also prepare the m/c for use by doing tasks like setting the hostname, starting SSH daemon and configuring the network interfaces
       + they are place in '/etc/init.d' and symbolic links are made to them from respective, numbered directories like /etc/rc0.d
         + % cd /etc/init.d # traditional init scripts
         + % ls -ltr # see lot of scripts
         + % vim network # bash script executing network related operations
         + % cd ../rc0.d # rc0 is run level 0 and contains symbolic linked scripts to /etc/init.d, these is where scripts run, exists for each run level 0,1,2...
       + native systemd services files instead of traditional init scripts
         + % systemctl # list of current running services
         + % systemctl list-unit-files # list of all services (running, disabled, stopped and masked)
         + % systemctl start <service> # start service
         + % systemctl stop <service> # stop service
       + the init (or upstart) process ensures that the correct scripts are executed depending on the requested run level to which the system till boot
**** system run levels
     + system run levels
       + a run level is a specific state of a unix/linux system, they vary from one system to another but following are generally common
         + 0: halt, the system is shutdown
         + 1: single user mode
         + 2,3,4,5: networking is enabled
         + 6: system is rebooting
       + in linux, runlevel 3 is used for a non-gui session, while runlevel 5 is used for a gui-desktop session
       + default run level of the system can be configured in '/etc/inittab' file
       + you can move from on runlevel to another including shutdown and reboot, by using the 'telinit' command followed by the desired run level
       + 'telinit -q' - will force the system to re-read the '/etc/inittab' file
         + % vim /etc/inittab # change runlevel id:5 to id:3
         + % reboot # booted to text interface
         + % root # login and enter password
         + % ping 8.8.8.8 # ping dns server
         + % telinit 5 # boots into runlevel 5 (gui-desktop)
     + init process
       + startup scripts are used to both start,stop and restart daemons (e.g /etc/init.d/httpd start)
         + % cd /etc/init.d
         + % ./sshd stop # stop service
         + % ps -ef | grep ssh
         + % ./sshd start # start service
         + % ps -ef | grep ssh
         + % ./sshd restart # restart service
       + scripts are placed in '/etc/init.d' and symbolic links are located in '/etc/rc.*.d' where * indicates the run level at which the script should run
         + % cd /etc/rc5.d
         + % ls -ltr
       + init process looks at rc.d directories to deterine which scripts to run, depending on the configured run level
       + in an rc.d directory, the script name (symbolic link) starts with an S (start) or K (kill) followed by a number. e.g. K35smb. numbers ensure dependency between different services (if 'httpd' daemon started before the network service does, it will fail)
       + when transitionling from run level 3 to run level 5, init runs all the scripts that start with S in '/etc/rc5.d' in an ascending order passing 'start' as a command line argument to them
       + red hat implementation
         + init uses '/etc/rc.d/rc' script passing the run level as an argument
         + the scripts place an empty lock file in '/var/lock/subsys' with the same name as the daemon. presence of this file means that the service is up and running, this file is deleted when the script is called with the stop argument
         + 'chkconfig' - command is used to install, remove and manage startup scripts
           + 'chkconfig --add <script_name>' - will add the script to the configuration
           + 'chkconfig --level <script_name> on | off'  - will enable/disable an added script in the specified run level
           + 'chkconfig --del <script_name>' - will remove the script from the configuration
           + 'chkconfig --list' - will print all the configured startup scripts, works best with grep
         + '/etc/rc.d/rc.local' - which is run after all other boot scripts have finished execution, you can use it to add custom startup scripts
         + % ls -l /etc/rc.d/rc
         + % vim /etc/rc.d/rc  # go through init script
         + % ls -l /var/lock/subsys/ # lists of lock daemons
         + % chkconfig --list  # lists of scripts
         + % vim /etc/rc.local # custom local rc script runs after rc script
**** lab exercise: creating a custom daemon
     + lab exercie
       + % vim /opt/timed # convention to end name with d for daemon; /work/booting-and-shutting-dowm/timed
       + % chmod +x /opt/timed
       + % /opt/timed # test script before adding it to init script
       + % ctrl-c
       + % tail /tmp/timed.log
       + % vim /etc/init.d/time # script time; /work/booting-and-shutting-dowm/time
       + % chmod +x /etc/init.d/time
       + % /etc/init.d/time # test script time
       + % /etc/init.d/time start # runs in backgroup
       + % ps -ef | grep timed
       + % /etc/init.d/time stop # stop timed script
       + % ps -ef | grep timed
       + % chkconfig --add time
       + % chkconfig --list | grep time # check time script is added and config to run on 3,4,5
       + % ls -l /etc/rc0.d/ | grep time
       + % ls -l /etc/rc3.d/ | grep time # check symbolic link
       + % vim /etc/inittab # change reboot to run level 3
       + % reboot
       + enter login and password
       + % ps -ef | grep time # timed is running and parent process is 1 which is init process
       + % vim /etc/rc.local # to add script in the rc local file
     + ubuntu deprecated 'upstart' method of running scripts and follows same as red hat now
     + shutting down and rebooting the system
       + 'shutdown' - command is the safest way to halt a systme or make it enter single user mode
         + % shutdown --help # shutdown help
         + % shutdown -h 22:00 "This system is coming down shortly" # shutdown at 22:00
       + 'shutdom -h time "message"' - shutdown the system at specified time, sending the passed on message to the logged in users
         + 'shutdown +10 "message"' - shutdown the system after 10 minutes from now
         + '-h' - forces the system to sync filesystems, write any buffers in memory to the disk, '-n' ignores this step, its primarily used by the fsck command after repairing the root partition to ensure that the kernel does not overwrite the repaired superblocks with cached data
       + 'shutdown -r' - rebooting the system
*** user access control
**** user access control fundamentals
     + the ownershop concept
       + linux regards files and processes as objects, objects have owners and owners have almost unrestricted control over their own objects
       + the root account is the system administrator's, it can take ownership of any object
       + processes control the access to themselves internally, e.g. passwd command with a non-root user change his own account, but it won't let him reset another user's passwd
         + % cat /etc/passwd
         + % su - user1
         + % passwd # user1 can change his passwd
         + % passwd user2 # can't change user2 passwd, only root can specify a user name
       + filesystems control access to files and directories. filesystems are the only object type that implements the concept of "groups"
       + groups can contain a number of users, if the group has some permission on a file or directory, all group members have this same privilege
         + % ls -l /opt/sample.txt
         + % su - user2
         + % echo "sample" > /opt/sample.txt # permission denied
         + % logout
         + % usermod -aG user1 user2
         + % su - user2
         + % id
         + % echo "sample" > /opt/sample.txt # it will write to the file
         + % cat /opt/sample.txt
         + % ls -l /opt/sample.txt
     + filesystem security model overview
       + users and groups own files and directories, only owner user can change the permissions of his own file or directory
       + the filesystem views users and groups as number rather than textual names, e.g. root is identified by UID of '0' and wheel group as GID '10'
       + when an access attempt occurs from a user or a group, the filesystem will use the UID and/or the GID to grant or deny access
       + UID's and GID's are stored in '/etc/passwd' and '/etc/group' respectively, when a command like 'ls -l' is used to display ownership info, those files will be consulted to display the human-friendly name rather than the id
       + 'id' - command to display your own UID
       + 'id -g' - command to display the group
     + process security model overview
       + any process owner can send signals to it (e.g. 'kill -9'), he can also increase it's 'nice' value or decrease it's priority on cpu using 'renice' command
         + % vim proc.sh
           '#!/bin/sh
           while true; do
             sleep 1
           done
         + % nohup bash proc.sh &; # runs in background
         + % ps -ef | grep proc;
         + % renice +5 <process id>; # values ranges from -20 to +20
         + % renice -5 <process id>; # permission denied, only root can increase the priority
         + % kill <procee id>;
       + process or command when it runs, has following user and group id's
         + real - the account of the owner of this process
         + effective - this is same as real id's, but sometimes it is changed to enable a non-privileged user to access files that can be only accessed by root. e.g 'passwd' when run by a normal user to change this own password, the effective id becomes 0 to enable the user to make changes to '/etc/shadow' file. the process will check the real id of the user to grant or deny access accordingly
           + % ls -l /etc/shadow; # nobody can change this file, but will happend through effective id's
         + saved - it's used when a process is running with a elevated privileges needs to do some work temporarily, as a non-priviledged account. it saves the priviledge id to the 'suid' so that it can use it back as its effect id
**** the power of root
     + the power of root
       + the root account has id of '0', id '0' can do any operations on any other file or process
       + some tasks can only be performed by root account
         + setting the m/c hostname or ip address
         + changing the system's date and time
         + open network sockets on privileged ports (below port 1024)
       + the uid '0' process can even change it's own uid and gid, this happens when a normal user logs into the system, login process changes it's uid and gid to those of the user, this change cannot be rolled back
       + passwd should be atleast 8 characters long
       + using mix of numbers, special characters, small and capital letters is good but hard to remember and need to store it somewhere or type slowly, so it posses security risk
       + best approach is to use passphrases like "IhateSUSELinux10!", it's long has special characters contains numbers and easy to rember by you only
       + root passwd should be changed every 3 months, it's advisable to store root passwords, and maximum security measures should be applied to the place/software they're stored in
       + its not good idea to login as root
         + you lose the user accountability: who did what and when
         + most admin's do not apply password locking on root passwords, because this may completely lock the system with no direct solution to unlock the root account
       + recommended approach is to give administrators normal, unpriviledged accounts, when the root power is needed, they either 'su' to root or use the 'sudo' command
       + 'su' command
         + short for 'substitute' user
         + you can use it to change your current login session to a different user session or to root
         + root can su to any user without specifying the password
         + 'su user' - does not load the user's environment
         + 'su - user' - loads the user's environment
         + type 'exit' or 'ctrl+d' to exit from su
       + to disable root login, add in '/etc/ssh/sshd_config' (ssh config file) and add 'PermitRootLogin no'
         + % vim /etc/ssh/sshd_config; # add 'PermitRootLogin no'
         + % service sshd restart; # restart sshd service
         + disable only ssh login but never disable console login for root
**** delegating root powers with sudo
     + 'sudo' is used to specify specific commands to be run as another user or typically as root
     + 'sudo <command>' - for root
     + 'sudo -u' - command as user
     + 'sudo -g' - command as group
     + for it to work, the user has to be in the '/etc/sudoers' edited using command 'visudo', it ensures that the file contains no errors, and that no one else is editing the file at the same time
       + if 'visudo' shows error type 'e' when prompts 'what now?' to edit and fix error
     + user with sudo can continue running commands without being prompted for password for 5m
     + all 'sudo' commands are logged into a log file. you can use 'syslog' to forward the logs to a central log host
     + working with '/etc/sudoers'
       + the line that adds privileges to a user has the following format
         + 'user HOSTS=(USERS:GROUPS) COMMAND1,COMMAND2...'
       + you can also use command aliases, many of them are already defined in '/etc/sudoers' file
       + the 'HOSTS' part is used so that the 'sudouers' file can be shared across multiple machines
       + a user's groups can be denoted by %, e.g. %wheel is the wheel
       + optionally, you can add 'NOPASSWD : ALL || commands' to instruct sudo not to ask for passwords for specific commands or for all commands
       + if the commands you are delegating for users include those which can spawn other processes (like vi, vim and less) you should add 'NOEXEC:command' to avoid letting the use open a complete shell with the sudoed account
       + go through '/etc/sudoers' file
       + % su - user1
       + % sudo service ntpd restart; # ntpd - network time server
       + % sudo -k ; # mode where it asks for password every time
       + % logout
       + % visudo
         'user1 ALL=(root) /usr/bin/vim' # only vim exec privilege is provided
       + % su - user1
       + % vim
         ':! bash' # entering bash 
         b% id # still as user
       + % sudo vim
         ':! bash'
         b% id # now as root
       + % logout
       + visudo
         'user1 ALL=(root) NOEXEC:/usr/bin/vim' # doesn't run shell now
       + % su - user1
       + % sudo vim
         ':! bash' # bash shell denied
       + % logout
       + % visudo
         'user1 ALL=(root) NOPASSWD:/usr/bin/vim'
       + % su - user1
       + % sudo -k
       + % sudo vim # doesn't ask passwd anymore
       + % logout
       + % visudo
         'user1 ALL=(root) ALL' # access to all command with root permissions
       + % su - user1
       + % sudo -i # enter passwd, gives new shell
       + % whoami # is root
       + % logout
       + % logout
       + % tail /var/log/secure # log file, prints very verbose logs
       + % sudo tail /var/log/auto.log # log file in ubuntu
**** system access
     + system access
       + they are user accounts used to execute system services, idea is to use them instead of using the root account for such tasks
       + they are protected from being used for login, by placing an asterisk instead of password hash in the shadow file, also by settings the default shell to '/bin/false' or '/bin/nologin'
         + they donot have home directory
       + their uid's are generally under 100
       + % sudo vi /etc/passwd # you can see service account like daemon, bin, sys, sync, games, man, lp, mail ...
       + % sudo adduser --system --no-create-home --uid 99 time; # adding system user 'time'
       + % vi /etc/passwd # user time is created as system account
       + % ls /home/time # not time home directory
       + system account are exempted from passwd aging policy as they aren't used for login
*** controlling processes
**** process control fundamentals
     + process
       + representation of running program
       + used to monitor and control the program's access to system resources like cpu, memory and i/o
       + the kernel allocates memory for each process, typically measured in "pages", the location of this address space (memory or swap) cannot be determined as unix combines both in virtual memory (memory + swamp)
       + important info about process recorded by kernel - owner, the state (running, sleeping ... etc), execution priority (nice value), the resources usage (files, network sockets ... etc)
     + identification
       + the kernel assigns a unique identifier to each process call PID
       + when the process demands a new program (process) to be started, it clones itself first, then the clone replaces the initial program with the desired one. the original process here is called parent and it's id is referred to as parent ID or PPID
       + the ppid can be used to trace the source of a running process, it can also be used to track the behavior of a given process (how many and what processes it is spawning)
       + % ps aux | head # you can see PID
       + % ps -ef | head # you can see PID spawning from PPID
**** ownership
     + ownership
       + the real UID (RUID) is the user id of the process owner
       + the effective UID (EUID) is the id of the user that the process is using temporarily to do some tasks. this is often the root id (0), this behavior can be found in programs that have setuid like passwd
       + the group id 'gid' is treated the same as the 'UID', with 'GID' and 'EGID'
       + the gid is not used most of the time, instead 'EGID' and the supplementary group list determine the process access permissions, because a given process may need to use one of the supplementary groups to be granted the required access level
       + % su - user1
       + % id; # uid, gid, groups - supplementary group
       + % groupadd admin; # creating group admin
       + % usermod -aG admin user2; # add user2 to group admin
       + % su - user2
       + % id; # you can group 'admin' in groups
     + cpu priority
       + the kernel internally determines how much cpu time a process is allowed to consume
       + the admin can set this value manfully, it is called the nice value, it ranges from -20 (highest priority) to 19 (lowest priority)
         + % top; # see pid, NI-Nice value
       + default, child process inherits its parent's nice value
       + a normal user can use the renice command to lower the priority of his own process (positive value), but he cannot use it to increase it's priority even to it's original value, the superuser can place any nice value on any process on the system
         + 'renice value pid'
         + infiniteloop.sh
           '#!/bin/bash
            while true; do
            sleep 1
            done'
         + % ./infiniteloop.sh &
         + % top; # NI=0 (nice value)
         + % renice 5 <pid>; # NI=5
         + % renice 0 <pid>; # permission denied
         + r% renice 0 <pid>; # renice to lower value as root is allowed
       + the nice value only controls the cpu time assigned to the process and not the utilization of memory or i/o
       + the nice command is used to start a process in the specified nice value
       + the most common use of the nice command is when the system is under high load and you want to start a shell to investigate the issue. starting a normal shell will cause a lot of logging
         + 'nice -n value /path/to/command'
         + % nice -n -10 bash; # will start a bash shell in a higher priority than other processes
**** process spawing and termination
     + process spawning and termination
       + a running process can launch a new child process by using the 'fork' system call, this creates an identical clone of the running process, but has some differences
         + a different and unique pid, zero cpu and memory consumption (initially) and empty list of pending signals
       + the child process 'exec' command (system call) to execute the new program
       + when the child process dies first, the parent process issue the 'wait' system call to notify the kernel that the child process is ready to vanish, it also receives the exit code that indicates why and how the termination occurred (0 means normal)
       + if the parent process dies first, the child process becomes orphaned, in this case, the 'init' process becomes the parent
       + % cd /opt/
       + % nohup ./infiniteloop.sh &; # infinite loop program, nohup - not kill the process on logout
       + % ps -ef | grep infini; # parent pid (ppid) is 10876
       + % logout
       + r% ps -ef | grep infini; # login as root, ppid is transferred to init (ppid)
     + communicating with a process
       + a running process can receive signals from the kernel, the user or other processes as a means of communication
       + the process may respond to the signal (if programmed to) or the kernel will act on behalf of the process and respond to the signal
       + most familiar signals
         + num:name:shortfor:sentwhen
           1:SIGHUP:Hang-Up:The controlling terminal has been closed
           2:SIGINT:Interrupt:Break key is pressed (like ctrl-c)
           3:SIGQUIT:Quit:The user wants the process to terminate and provide a core dump file. Sent by ctrl-y or ctrl-\
           9:SIGKILL:Kill:Terminate immediately. This signal cannot be ignored and the process does not perform any clean up before exiting
             + SIGKILL (kill -9) is not recommended, as it need to kill immediately programms will not be able to catch this signal and do cleanup before terminating
           11:SEGV:Segmentationfault:The process tries to access virtual memory that does not belong it to. The process is terminated and core dump is provided
           15:SIGTERM:Termination:The process is asked to terminate. The signal can be caught and ignored, allowing the process to perform a clean shutdown
       + in shells like csh, the HUP signals are ignored automatically, that is, you can run a program in the background and it will continue to run after you logout of the shell. in shells like BASH, this has to be done by placing 'nohup' before the command
**** terminating a process
     + terminating a process
       + use the kill command to terminate a process, 'kill' command sends a TERM signal by default, but it can be used to send any other signal as an argument to the command
       + the 'TERM' signal does not necessarily kill a process because it can be intercepted by the program and ignored
       + the 'SIGKILL' signal is often enough to terminate a process, in some cases a reboot is required to kill a process which is waiting for a response that will never come from a disk or network device
       + you can use 'killall process_name' to kill all the processes associated with a program, beware that in unix the same command will kill all the processes initialized by the current user. if it's root, the system will halt immediately
       + the 'pkill' command can be used to kill a process by it's name
     + process modes
       + S - the process is sleeping, it's waiting for something or a resource
       + R - the process is running or runnable, it is being executed or can be executed whenever the CPU time is available
       + Z (defunct) - the process is supposed to be dead but it's not (zombie), normally it wil die shortly, it not a reboot may be required
       + T - the process is suspended (traced), this can be obvious if you pressed ctrl-z to pause a running command
       + % top; # "S" - process state
       + % cd /opt
       + % ./infiniteloop.sh
       + % ctrl-z; process stopped
       + % top -pid <processid>>; # "S" is T (suspended)
     + ps command
       + is the defacto command of process monitoring
         + 'a' - show all processes not just the current user's
         + 'u' - user oriented output
         + 'x' - show also processes that were not started from the terminal
         + % ps aux; # RSS - total virtual memory the process is using
         + 'l' - instead of 'u' to print the long version of the output, this prints the uid as a number rather than the username
         + % ps lax; # longer output
         + 'ef' - similar output can be obtained by using this switch
         + % ps -ef; # shorter output
     + real time process monitoring
       + 'top' - command offers a real time view of the processes running on the system with many useful information like the amount of CPU and memory used, output is sorted by the cpu, but you can choose another sort field
         + % top
       + you can use top command to dynamically renice processes
       + another command that extends 'top' (third party) is 'htop'
         + http://hisham.hm/htop/index.php?page=downloads
       + 'top' is not a priviledged command, it can be run by other users than root
       + the default refresh interval is 3 sec, this can be modified by using the '-d' option
**** using the /proc filesystem
     + using the /proc filesystem
       + it's virtual filesystem that is created on the fly when the system boots
         + % ls -l /proc
       + completly destroyed when system shutdown's
       + contains useful info about the processes currently running
       + you can use 'ls' to list the files and directories. 'cat' to show file conctents just as you deal with any other filesystem
       + given a process pid, you can access it's properties in '/proc' like this 'ls -l /proc/<pid>'
       + some useful directories
         + 'fd' - for the file descriptors used by the process (STDIN, STDOUT, STDERR and any files currently being written too, like log files for example)
         + 'cmdline' - command line that the process was started with
         + 'cwd' - a symbolic link to the process working directory
         + % ps -ef | grep http
         + % cd /proc/<httpps>
         + % ls -l
         + % ls -l fd; # file descriptor; 2->stderr is redirected, process can have any no. of descriptor and can be redirected
         + % ls -l cmdline
         + % cat cmdline
         + % cat cmdline && echo; # echo prints new line
         + % cd cwd; # working directory of the daemon
         + % ls -ld cwd; # symbolic link
     + tracing a process
       + 'strace' - command to monitor the system calls that a process makes on a very level
       + 'strace' is useful when you want to troubleshoot a hanging or a frequently crashing process, because you will know exactly what was the last thing the process was trying to do before it crashed or kept on waiting for
       + '-f' - to trace child processes (forked) as well
       + '-e' - can be used to direct the output to a file, this is useful when you want to monitor a process that will take a very long time and you want to analyze it's behavior over that long period
         + % strace -p <httppid>; # tracing httpd daemon
         + % ctrl-c
         + % ps -ef | grep ntp; # ntp - time server, get pid
         + % strace -p <ntppid>
         + % strace -f -e strace.out -p <ntppid>; # traces all the child processes and write output to strace.out
*** the file system
*** adding new users
*** storage
*** periodic processes
*** backups
*** syslog and log files
*** tcp/ip networking
*** netfilter and ip tables
*** dns: the domain name system
*** the network file system
*** sharing files with windows
*** email services
*** network management and debugging
*** security
*** ssh tips and tricks
*** web hosting
*** performance analysis


* linux
** udemy - fundamentals of unix and linux system administration - eduonix
*** where to start
**** linux unix administration
     + an administrator is not expected to be a "walking book". linux has a huge number of commands, with a lot of different options and arguments. effectively using the man pages, and figuring out how a specific command works is an indispensable skill
     + https://en.wikipedia.org/wiki/List_of_Linux_distributions - Linux Distributions
     + most common linux - redhat (centos, oracle linux, fedora), debian (ubuntu), suse
**** getting help on linux
     + MAN pages - manual pages
       + 'man command' - e.g.
       + several sections 
         + commands and applications (man 1)
           + 'man passwd' - modify a user's password - PASSWD(1)
           + 'man 5 smb.conf' - samba configuration file
           + 'man 1 smblclient' - various options of smbclient command 
         + system calls (man 2)
         + library calls (man 3)
         + drivers (man 4)
         + files (man 5)
           + 'ls -l /etc/passwd' - passwd of users and other info
             + 'man 5 passwd' - this give section 5 passwd man page
         + and more
       + you can use (similar to) 'more' or 'less' command shortcuts for navigation
         + '<space>' - moving forward
         + 'ctrl+b' - moving backword
         + 'ctrl+f' - moving forward
         + ':q' - quit
         + '/<keyword>' - search keyword
       + 'man -k keyword' - search for (inside description or title) a specific man page 
         + 'man -k update' 
         + 'man -k printf'
       + 'man -a keyword' - search in the title only and display multiple man pages
         + 'man -a printf' - gives first man page occurance then next and next
**** advance man command
     + 'man -af keyword' - to search only in the title
       + 'man -af passwd'
     + '<command> -h' or '<command>' or '<command> --help' - provide help, sometimes useful as man's are lenghty
       + 'find' - gives option, check 'man find'
     + 'whatis <command>' - to know whether a command is installed on not or want to know it's path
     + to update man page
       + redhat: 'makewhatis'
       + ubuntu, suse: 'mandb'
     + 'which <command>'  - find the path of a command
       + 'java' - gives java command options
       + 'which java' - java path
     + 'history' - list the commands that you have issued
       + 'export HISTTIMEFORAMT="%d/%m/%y %T "' - set env variable to show time stamp
     + 'du:' - find amount of space taken by a file or directory
       + 'du -h -max-depth=1 *' - find the file and directory sizes in the current location in a human readable format
         + 'du -h -d=1 *' - in mac
     + 'echo > file' - empty a file without deleting it
     + other online documentation
       + linux.com
       + kernel.org - related to kernel, sourcecode is available
       + serverfault.com - important one, q&a site
*** package management
**** introduction to package management
     + traditional way
       + download .tar.gz files
       + './configure' and 'make install'
       + doesn't handle dependencies, may overwrite customized configuration files, hard to uninstall
       + centos:
         + % ls -ltr; # download htop-1.0.3.tar.gz
         + % tar -xvf htop-1.0.3.tar.gz; # famous package to monitor cpu and memory performance
         + % ./configure; # check for the system, we don't have gcc compiler
         + % ls -l /etc/ntp.conf; # network time server to sync with your own time; this file can get overwritten during installation and older config can be deleted
     + packages
       + preserves configuration files
         + e.g. if new version of httpd is installed, the httpd.conf is created as httpd.conf.rpmnew
       + dependencies are considered
       + pre and post install scripts can be deployed with the application
       + multiple packages can be wrapped in same package
         + https://www.libreoffice.org - famous office suite for linux, it's a multiple package
       + can easily uninstall or exclude their dependencies
       + linux package types
         + rpm - red hat package (.rpm), used by red hat, suse; to install use 'rpm' command
           + % rpm; # gives options
           + % rpm -i; # install command
           + % rpm -U; # update command
         + debian - ubuntu and other debian systems (.deb); to install use 'dpkg' command
         + both of these commands don't handle dependencies, cannot be used to search for packages and do not offer metadata about package
           + centos:
             + % ls -l vim-enhanced-7.4.629-5.el16.x86_64.rpm; # download vim enhanced package
             + % rpm -i vim-enhanced-7.4.629-5.el16.x86_64.rpm; # rpm install, it fails because of dependencies
         + yum (yellowdog updater modified), apt (advanced package tool) and zypper are introduced to overcome shortcoming
**** installing from RPM
     + redhat rpm:
       + -i : install; -U : upgrade; -e : erase; -q : query (used with other options)
       + % rpm -qa; # displays all packages installed on the system
       + % rpm -qa | grep <package>; # to determine whether package is installed or not
     + debian's dpkg:
       + --install; --remove; -l - to display installed packages
       + % dpkg -l | grep <package>; # to determine whether or not a package is installed
     + package managers
       + it needs repository, a repository is like a container containing packages, with their respective metadata
       + each vendor offers it's own repository (repo). packages are offered for download in HTTP or FTP
       + 'yum install' (red hat)/ 'apt-get install' (ubuntu)
       + redhat yum:         
         + % yum install lsof; # centos: package gives vast info about system, processes, network sockets, users using directories etc
         + '/etc/yum.repo.d/public-yum-o16.repo' - yum repo
       + ubuntu apt-get
         + % apt-get update; # update the local cache data sources (repositories) to reflect the latest changes, do update before any installation
           + '/etc/apt/sources.list' - file contains the source URLs for the packages, you needn't change this file unless you want to use your own apt repository
             + file contains types of packages those fully supported by ubuntu (main), unsupported open source packages (universe) and paid unsupported packages (multiverse)
**** making a local apt-get repo
     + used if you are managing a large number of ubuntu machines, and you need all of them share one local repo to save bandwidth
       + % apt-get install apt-mirror ; # install apt-mirror
     + /etc/apt/mirror.list - configuration file
       + % apt-mirror ; # starts mirroring process, first time takes lot of time. subsequent runs will consume much less time and can be automated by using cron jobs
     + /var/spool/apt-mirror - directory where packages are download, need atleast 50GB (path can be change in configuration file)
       + % ls -l /var/spool/apt-mirror/skel/archive.ubuntu.com/ubuntu
     + '/var/spool/apt-mirror/var/clean.sh' - delete obsolete packages
     + make it web reachable via HTTP or FTP (like symbolic link from your web directory to the packages directory)
       + % cd /var/www/html/
       + % ln -s /var/spool/apt-mirror ubuntu
       + % ls -ltr
     + all clients have to change their sources.list files to point to the local repo
     + you can automate system upgrades by using cron jobs, run 'apt-get update' before upgrade to ensure that you have the latest data
     + 'apt-get upgrade' or 'apt-get dist-upgrade' - upgrade command, later may delete packages that are not compatible so use it with care
     + '--yes' - use it for full automation, this will confirm all dialogs, use it with care
     + some updates require system reboot to be reflected like kernel upgrades
     + '--download-only' - to download the packages only and install them later after reviewing it
       + /var/cache/apt - packages directory
       + 'apt-get install /var/cache/apt/<package>' - to install/update specific package
       + 'apt-get autoclean' - to remove files that are no longer used
**** making local yum repo
     + /etc/yum.conf - configuration files
       + by adding 'proxy=http://proxy:8080' to /etc/yum.conf you can instruct yum to download and install through proxy
     + /etc/yum.conf.d - repositories themselves, you can add repo info to the same config file, but this is a bad practice
     + 'yum update' - to make system-wide upgrade, 'yum upgrade' does the same task, different meaning to 'apt-get update'
     + 'yum install' - install packages
     + 'yum update' - upgrade
     + 'yum remove' - uninstall packages
     + '-y' - auto-confirmation, discretion is advised
     + 'yum install http*' - will install httpd, asterisk before and after partial package name works
     + 'file:///' url points to the mounted filesystem of the DVD (not the live CD)
       + if needed, this can be further extended to serve other systems on the same network form the same DVD
       + use symbolic link in the web directory that points to the mounted DVD filesystem and update the appropriate client repo configuration to point to it
     + % ls -l /dev/sr0' - cdrom location (redhat dvd)
     + % mount /dev/sr0 /mnt/ - mount cdrom
     + % cd /mnt/
     + % ls -l
     + % cd packages; # lot of rpm packages
     + % cd /etc/yum.repos.d; # update repo
     + % vi media.repo; # new file
       + add '[DVD]
              name="DVD repository"
              baseurl=file:///mnt
              enabled=1
              gpgcheck=0
             '
     + % yum repolist; # check repo list
     + % yum --disablerepo=public_* install httpd; # temporarily disable public repo, install from DVD
     + % cd /var/www/html; # defaul web directory of httpd
     + % ln -s /mnt/ RedHatRepo; # make symbolic link
     + % service httpd start; # start httpd service
     + % iptables -vnL; # ensure firewall didn't disable http traffic
     + % iptables -F; # temporarily disable firewall
       + in browser https://<ip>/RedHatRepo - packages are visible
       + all m/c in network can use http service to install packages
     + local mirror
       + done using 'reposync' command, it's part of 'yum-utils' package
       + % yum -y yum-utils
       + % mkdir /repository; # should have sufficient space 50GB
       + % cd /repository
       + % reposync -r public_o16_latest -p /repository/; # to get repo rame vi /etc/yum.repos.d/public-yum-o16.repo, downloads packages locally
       + % cd /repository/public_o16_latest
       + % ls -l; # list of packages
       + % yum -y install createrepo; # install createrepo
       + % createrepo .; # create repo on directory; creates metadata 'repodata' directory
       + make a symbolic link from your web directory to the packages directory to make it web reachable
       + make appropriate changes to the clients repo configuration files to point to the new mirrored repo
**** tips and tricks
     + yum plugins
       + add extra features to yum and they are powerful
       + 'yum-fastestmirror' - makes yum auto choose the fastest connection to mirro
         + /var/cache/yum/timeshosts.txt - data is stored, you can force yum to recheck the fastest connection by removing this file
         + % yum -y install yum-fastestmirror
         + % yum update
       + 'yum-security' - enables yum to use the '--security' command line argument which makes yum ignores any packages other than the security related
         + % yum -y install yum-security
         + % yum --security update; only security related update
       + 'yum-presto' - decreases the download size when updating a package by downloading only the change between the installed and the new one (delta rpms)
         + % yum -y install yum-presto
         + % yum update
       + 'yum search <package>' - to search package
         + % yum search ssh; # list of packages that contains
       + 'yum whatprovides *command*' - some commands are part of packages that have different names, to search for them
         + % yum -y install scp; # scp not found because scp is not a package
         + % yum whatprovides *scp*; # look for openssh-client-*, this is the package that needs to be installed
         + % yum -y install openssh-clients
       + 'yum info <package>' - info about package
         + % yum info openssh-clients; # info about openssh
       + 'yum groupinstall group' - to install groups of packages like a desktop environment
         + % yum -y groupinstall "Desktop" "Desktop Platform" "X Window System" "Fonts"; # install group of packages
       + 'yum clean all' - to recreate cache (useful if you are behind proxy)
         + % yum clean all
         + % yum update; # it's re-downloading packages
*** shell scripting guide
**** introduction to shell scripting
     + saves time and effort. can be scheduled if use in Cron job
     + sh (bourne shell) is dominant one before bash (bourne again shell). other shells include ksh (korn shell) and csh (c-shell). default shell on centos and ubuntu is bash
     + csh used to make c programmers feel at home
     + % ksh; # starts ksh
     + if the task at hand is much more complex than to be solved by a bunch of shell commands, you can opt to use a fully fledged language like python or perl
     + if you are an emacs user, you can use following shortcuts to communicate with the shell
       + ctrl-e - jump to the end of the current line
       + ctrl-a - move to the line beginning
       + ctrl-p - brings the last used command
       + ctrl-n - brings the next used command
       + ctrl-r - lets you search for commands in history of the last used ones
     + 'set -o vi' - to enter vi mode at cli
     + 'set -o emacs' - to enter emacs mode at cli
     + process file descriptors (fd)
       + a process communicates with the system using channels called file descriptors (fd)
       + atleast 3 channels are available to a given process
         + stdin - standard input, for which the process accepts input, it is numbered as 0
         + stdout - standard output, to which the process directs any output produced, it is numbered as 1
         + stderr - standard error, to which any error messages are directed, it is numbered as 2
       + % ps -ef; # processes running in the system
       + % ls -l /proc/45163/fd; # to examine the current fd's used by a process by listing the files under the virtual directory /proc, where 45163 is process number
         + /proc - not real directory, it provides you important info about running processes
       + redirect standard output and standard error to a file using '>' and '>>'
         + % useradd user1; # add user1
         + % su - user1; # su user1
         + % find / -name core > output.txt 2>error.txt; # output to output.txt and error to error.txt
       + direct both error and output to the same destination using '&>'
         + % find / -name core &> output.txt; # both output and error to output.txt
       + instruct the process to take it's standard input from a file using '<'
         + % mail -s "output" root < output.txt; # write mail with output.txt as input
         + % mail; # check mail
       + inject the STDOUT of a command to the STDIN of another using the '|' (pipe)
         + % ls -l | grep install; # '|' is pipe
**** using variables
     + 'USER=joe' - example to assign a variable USER with value jeo, no space between '=' sign
       + % newvar="This variable contains text"
     + '$USER' - to call a variable or ${USER}, useful when using variable with literal text like ${ORACLE_HOME}/oraInventory
     + ''$HOME'' - will print $HOME
     + '"$HOME"' - will print home directory path of current user
     + you can add your environment variables in ~/.bash_profile or ~/.profile
       + % env; # lists env
     + 'cut' command
       + take STDIN, preform some processing on it before returning result as STDOUT
       + used to display parts of the input text, often used with delimited files like cs, and /etc/passwd
       + default delimiter is TAB character, but this can be changed using the -d command line argument
       + % cut -d , -f 1,3 < sample.csv; # to select the fields you want to display, use -f option followed by a comma separated list of numbers
       + % echo "This,Is,Cut,Example" | cut -d , -f 1,3; # prints This,Cut
**** the sort command
     + 'sort' command
       + sorts the lines of text give to it, type of sort: numerical or dictionary based
       + % sort -t , -k1,1 -n < sample.csv; # wll sort the lines of sample.csv in an integer based way, regarding the comma as a column delimiter and the key column is 1
         + '-d' - sort by dictionary
         + the key column can be more than one so we must specify that it will take only one column by inserting a comma and providing an end value k1,1
         + '-r' - to reverse order
         + '-u' - to print unique values only
         + '-b' - to ignore leading spaces
       + sort is usually combined with another filter command like 'cut' or 'uniq'
     + 'uniq' command
       + it returns the unique lines of a given text input
       + '-d' - to print duplicated lines
       + '-c' - to count the number of duplicated/non-duplicated lines
         + % uniq -u < sample.csv; # doesn't change anything, it has be sorted first
       + to use 'uniq' lines must be sorted first
         + % sort -t , -k1,1 sample.csv | uniq -u; # shows unique values
         + % sort -t , -k1,1 sample.csv | uniq -d; # shows duplicated values
         + % sort -t , -k1,1 sample.csv | uniq -dc; # shows duplicated values and no. of occurance
         + % sort -t , -k1,1 sample.csv | uniq -c; # will print the number of times a line has been entered in the sample .csv file
     + 'wc' command
       + word count to count words, lines and characters
         + % wc sample.csv # gives all in words(space as delimiter) lines and characters
       + '-l' - for lines
         + % wc -l sample.csv # gives lines
       + '-w' - for words
         + % wc -w sample.csv # gives words
       + '-c' - for characters
         + % wc -c sample.csv # gives characters
       + to start and stop service
         + % service httpd start; # starts httpd service
         + % service httpd stop; # stops httpd service
     + 'tee' command
       + to view the standard output of command while it's being written to a file
       + it's like a monitoring command
         + % find / -name *.log | tee output.txt; # will print the output to the screen and to output.txt file at same time
     + 'head' command
       + prints the first 10 lines of a file
       + '--lines=n' - will print only the specified number of lines, can be used as head -n
         + % head -5 sample.csv; # prints first 5 lines
       + '--lines=-n' - will print all lines in the file except the last n lines
     + 'tail' command
       + prints last 10 lines of a file
       + '--lines=n' - prints the last n number of lines in a file, can be used as tail -n
         + % tail -5 sample.csv; # prints last 5 lines
       + '--lines=+n' - prints all lines in a file starting with line number n
       + '-f' - will keep the file open, displaing any new lines added to it. This is typically used with log files
         + % logger "Hello"; # logger logs message to a main file in the server
         + % logger "This is a log message"
         + % tail -f /var/log/messages; # displays logs
       + '--pid=PID' - makes the command exit after the process which is writing to the file you're tailing exits.
         + useful so that you know if the process has exited or it's just not writing any output at the current moment
     + 'grep' command
       + searches for text in it's standard input and outputs
       + you can use regular expressions in pattern matching
       + '-c' - get the number of matches instead of printing them
         + % ps -ef | grep -c ssh
       + '-i' - ignore case when searching
       + '-v' text - matches if the text is not present
         + % ps -ef | grep ssh | grep -v grep; # removes grep ps from output
       + '-R' - perform a recursive search in current directory and all subdirectories
         + % grep -l root .; # it will output files that contain the text, searches in current directory
         + % grep -Rl root .; # it will search sub directories
**** basics of bash script
     + % bash script.sh; # to run bash script
     + '#' - comment
     + ';' - mutiples commands are separated in the same line
     + add '#!/bin/bash' as first line to make script self executable
     + 'echo'  - to print text to screen
       + '-e' - make it work like printf (interpret special characters like \t and \n)
       + '-n' - do not add newline character to the end of the line
       + % echo "Hello\n"
       + % echo -e "Hello\n"
       + % echo -n "Please enter your name: " # doesn't add new line
     + 'printf' - also prints text, allows to output special characters like tabs (\t) and add newline character (\n)
       + % printf "Hello\n"
     + 'read' - accept input from user followed by a variable
       + % echo -n "Please enter your name: "
       + % read user_input; # input to variable user_input
       + % echo "Hello " $user_input
     + arguments
       + arguments are interpreted by bash as $1, $2, $3 and so on
       + '$0' - holds the name of the script file
       + '$#' - contains the number of arguments passed to the script
       + '$*' - contains all the arguments passed at one
       + command line argument variables with special ones can be used to test whether or not the user has supplied the correct input if at all
         + and print a friendly usage message accordingly
         + sample usage code
           '#!/bin/bash
           if [ [ $# -eq 0 ] ]; then
             echo "Usage: " $0 "your name"
             exit 1 # failed exit
           fi
           echo "Hello " $1
           exit 0 # success exit' 
**** shell functions
     + shell functions
       + 'function function_name { code }' - syntax
       + sample code
         '#!/bin/bash
         function usage {
           echo "Usage: " $0 "your name"
         }
         if [ [ $# -eq 0 ] ]; then
           usage
           exit 1
         fi
         echo "Hello " $1
         exit 0'
       + usage is not restricted to shell scripting, you can also use them as an alias to your shell commands
         + you can add a function to your .bash_profile and use it as a command
         + 'function grepv {
            grep -v grep
           }'; # in ./bash_profile
         + % ps -ef | grepv | wc -l; # grepv is shell function
         + % 'alias ls="ls -ltr"'; # this is fine, but function can have more complex code
     + variable visibility
       + variables are global by default, but a function can make variable accessiblity limited to their own scope by using keyword 'local'
         + the variable retains its original value as soon as code execution leaves the function where the variable was created as local
     + decision making
       + sample code
         'id=`id -u`
          if [ $id -eq 0 ]; then # spaces needed before and after the square brackes
            echo "This script cannot be run as root"
          else # you can use 'elif' for else if condition
            echo "Welcome to our script"
          fi'
     + test command
       + '[ ]' in if condition is shortcut to /bin/test command
       + 'man test' - check for full list 
       + equal to 
         + '=' - string like '$user = 'Sam''
         + '-eq' - number like '$id -eq 1'
       + note equal to
         + '!=' - string like '$user != 'John''
         + '-ne' - number like '$id -ne 5000'
       + greater than
         + '-gt' - number like '$count -gt 0'
       + less than
         + '-lt' - number like '$limit -lt 100'
       + greater than or equal
         + '-gte' - number like '$count -gte 0'
       + less than or equal
         + '-lte' - number like '$limit -lte 100
       + file attributes
         + '-d directory' - directory exists
         + '-e file' - file exists
         + '-f file' - file exists and is a regular file (not a block device for example)
         + '-r file' - file is readable
         + '-s file' - file is not empty
         + '-w file' - file is writable
**** looping
     + 'for..in' - loop to iterate over a group of values and perform some commands on each one
     + sample code
       'for f in *.log; do # can accept a group of files by using globing through asterisk * or a question mark ?
          echo gzip $f # always good idea to add echo to print operations on screen
        done'
     + sample code
       'for i in user1 user2 user3; do
          echo $i
        done'
     + classic for loop is available in bash
       + sampel code
         'for (( i=0; i<$count; i++)); do # i is not preceded by a $ in the loop definition
            echo $i
          done'
     + while loop
       + continue to iterate as long as a specific condition is met, often used in reading strings such as user input or a text file
       + syntax
         'while [ [ condition ] ]; do
            code
          done'
       + sample code
         '#!/bin/bash
         input=""
         while [ [ $input != 'Y' ] ] do
           echo -n "Please enter Y to continue"
           read input
         done'
       + syntax for infinite loops, this is typically done in daemons that work in the background, listening fo ran event and acting accordingly
         'while true; do
            code
            sleep n seconds # needed so that you don't exhaust your machine resources
          done'
       + sample code
         '#!/bin/bash
          while true; do # 'true' is to continue infinitely
            echo 'date' >> timestamps.text
            sleep 1
          done'
       + ./<shellscript> & # '&' is to run the script in background
       + 'jobs' - lists running job
       + 'fg %1' - run job 1 in foreground; 'ctrl+z' to stop foreground
       + 'bg %1' - run job 1 in background
       + % tail -f timestamps.text; # file is updating
**** perl
     + fully fledged programming language that is must more powerful than bash
     + perl or python are designed for shell scripting
     + % yum install perl; # centos perl install
     + % apt-get install perl; # ubuntu perl install
     + sample code
       '#!/usr/bin/perl
        # this is comment
        $myvar = "Eduonix";
        print "$myvar\n";'
**** perl arrays
     + sample code
       '#!/usr/bin/perl
        @users = ("user1","user2","user3"); # array assignment
        print "$users[1]\n"; # scalar print
        $count = $#users;
        print "This array has $count number of users";'
     + sample code
       '#!/usr/bin/perl
        @users = ("user1","user2","user3", "user4"); # array assignment
        @admins = @users[1,2];
        print "The admins are $admins[0] and $admins[1]\n";'
     + sample code
       '#!/usr/bin/perl
        %user = ("username" => "johndoes", "password" => "changeme", "name" => "John Doe"); # hash assignment
        print $user{"name"}."\n"; # '.' is concatenation operation
        @slice = @user{"username", "password"}; # slice operation
        print "Username is".$slice[0]." and password is ".$slice[1]."\n";
**** perl script arguments
     + sample code
       '#!/usr/bin/perl
        print "What is your name? ";
        $input = <STDIN>; # input from user or other process via pipe '|'
        chomp ($input); # chop trailing spaces
        print "Hello ".$input."\n";'
     + sample code 
       + % ./perlinput username password
         '#!/usr/bin/perl
          $count = $#ARGV + 1;
          print $ARGV[0]."\n"; # print arguments
          if ($#ARGV == -1) {
            print "Usage $0 username\n";
          }
          if ($count < 2) {
            print "Usage $0 username password\n";
          }'
     + 'if' syntax
       + 'if (condition) {
            code if condition is true
          }
          elseif (condition) {
            code if above condition is false
          }
          else {
            code if all conditions are false
          }'
     + perl operators
       + equal to - string - 'eq' - $user eq 'Sam'
       + equal to - number - '==' - $id == 1
       + not equal to - string - 'ne' - $user ne 'John'
       + not equal to - number - '!=' - $id != 5000
       + greater than - number - 'gt' - $count gt 0
       + less than - number - 'lt' - $limit lt 100
       + greater than or equal - number - gte - $count gte 0
       + less than or equal - number - lte - $limit lte 100
     + perl loops
       + for syntax
         'for ($i=0;$i<10;$++) {
          }'
       + foreach loop syntax, works best with arrays
         'foreach $var($variables) {
            $var holds the current array item value
          }'
       + while loop syntax
         'while (condition) {
            code
          }'
       + infinite loop syntx
         'while (true) {
            code
            sleep n seconds
          }'         
     + sample code
       + % ./pse -ef | ./perforeach.pl ssh # this is like grep function
         '#!/usr/bin/perl
          @input = <STDIN>;
          foreach $line(@input) {
            if (index($line,ARGV[0]") != -1 && index($line,"perl") == -1) { # index is string search function
              print $line;
            }
          }'
**** python scripting - part A
     + python is generally more readalbe than perl, language is maintained in two streams: 2 (latest 2.7) and 3 (latest 3.5). Both are considerably different
     + it has it's own interactive shell, which is useful to test your commands before putting them in a script
     + python is said to have batteries included, means that it has got a lot of built-in functionality that make it independently robust enough to handle most tasks
     + it uses modules to encapsulate different types of tasks like 'os' module, 'time' module
     + 'sys' and 'os' modules are working with shell scripting and operating system in general
     + sample code
       + % python -v # python version
       + % python # interactive shell
       + p% print "username"
       + p% ctrl+d # exit python
     + sample code
       + % ./mypython.py username
         '#!/usr/bin/python
          print ("Please enter your name ")
          input = raw_input()
          print ("Hello " +  input)
         '
     + if condition syntax
       'if condition:
          code if true
        elsif condition:
          code if previous condition is false and this one is true
        else:
          code if all conditions are false
     + sample code
       + ./mypython.py username
         '#!/usr/bin/python
          import sys # importing sys module
          if (len(sys.argv) == 1): # len is length python function
            print "Usage " + sys.argv[0] + " username"
         '
**** python scripting - part B
     + lists are like arrays, a group of values saved assigned to one variable
       + 'listname = [val1, val2, val3]
     + tuples are the same as lists, but they cannot be modified
       + 'tuplename = (val1,val2,val3)'
     + dictionaries can be thought as associative arrays, they contain key value pairs
       + 'mydict = {key1:value1,key2:value2,key3:value3}'
     + python loops
       + for loop syntax
         'for item in item_sequence: # item_sequence could be any variable that can be iterated over, a list or a tuple
            code'
         + sample code
           + % ./mypython.py username password
             '#!/usr/bin/python
              import sys
              i = 1
              for c in sys.argv:
                print ("Command argument " + str(i) + " is "+ c)
                i = i + 1
             '
       + while loop syntax
         'while (condition):
           code'
       + infinite loop syntax
         'while (True):
            code
            time.sleep(n seconds) # import time module'
     + you can make python execute shell commands by using the subprocess module, provides call function which will execute the command you pass to it as parameter
       + sample code
         + % ./mypython.py
           '#!/usr/bin/python
            import sys
            import subprocess
            output = subprocess.call(["ls","-l"]); # subprocess takes inputs as lists
            print output
           '
     + shell scripting is a robust way to automate repetitive tasks
*** booting and shutting down
*** user access control
*** controlling processes
*** the file system
*** adding new users
*** storage
*** periodic processes
*** backups
*** syslog and log files
*** tcp/ip networking
*** netfilter and ip tables
*** dns: the domain name system
*** the network file system
*** sharing files with windows
*** email services
*** network management and debugging
*** security
*** ssh tips and tricks
*** web hosting
*** performance analysis

